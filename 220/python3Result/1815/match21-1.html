<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>338_silvertint10.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>338_silvertint10.py</CENTER></H3><HR>
<PRE>
<A NAME="0"></A>class DSU:
    def __init__(self, n):
        self.uf = {i: i for i in range(n)}
        self.rank = {i: 1 for i in range(<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21-0.html#0',2,'match21-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>n)}
        # self.max = {i: 0 for i in range(n)}

    def find(self, x):
        if self.uf[x] != x:
            self.uf[x] = self.find(self.uf[x])
        return self.uf[x]

    def union(self, x, y):
<A NAME="1"></A>        px, py = self.find(x), self.find(</B></FONT>y)
        ans = False
        if px != py:
            <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21-0.html#1',2,'match21-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if self.rank[px] &gt; self.rank[py]:
                px, py = py, px
            self.rank[py] += self.rank[</B></FONT>px]
<A NAME="2"></A>            self.uf[px] = py
            # self.max[py] = max(self.max[px], self.max[py], d)
            ans = True
        <FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21-0.html#2',2,'match21-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return ans

class Solution:
    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -&gt; List[bool]:
        edgeList.sort(key=lambda x: x[2])
        # queries.sort(key=lambda x: x[2])
        Q =</B></FONT> sorted([(x, y, z, i) for i, (x, y, z) in enumerate(queries)], key=lambda x: x[2])
        m = len(queries)
        k = 0
        ans = [False] * m
        uf = DSU(n)
        for i, j, d in edgeList:
            while k &lt; m and Q[k][2] &lt;= d:
                x, y, z, idx = Q[k]
                if uf.find(x) != uf.find(y):
                    ans[idx] = False
                else:
                    ans[idx] = True
                k += 1
            if k == m: break
            uf.union(i, j)
        while k &lt; m:
            x, y, z, idx = Q[k]
            ans[idx] = True
            k += 1
        return ans
            
            
            
            
            
        
</PRE>

</BODY>
</HTML>
