<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>46_hahahiehie.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>46_hahahiehie.java</CENTER></H3><HR>
<PRE>
import java.util.*;

class Utils {
    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
<A NAME="0"></A>        int high = n;
        while (low &lt; high) {
            int mid = low + (high - low) / 2;
            <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match34-1.html#0',3,'match34-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>if (a[mid] &lt; target) {
                low = mid + 1;
            } else {
                high = mid;
            }</B></FONT>
        }
        return low;
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low &lt; high) {
            int mid = low + (high - low) / 2;
            if (a[mid] &lt;= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static &lt;T extends Comparable&lt;T&gt;&gt; int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low &lt; high) {
            int mid = low + (high - low) / 2;
            if (a[mid].compareTo(target) &lt; 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static &lt;T extends Comparable&lt;T&gt;&gt; int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low &lt; high) {
            int mid = low + (high - low) / 2;
            if (a[mid].compareTo(target) &lt;= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x &lt;&lt; 32) | ((long) y &lt;&lt; 32 &gt;&gt;&gt; 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K &lt;= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) &gt;&gt; 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i &lt; j) {
            while (i &lt; j &amp;&amp; nums[i] &lt; pivot) i++;
            if (i &lt; j) nums[j--] = nums[i];

            while (i &lt; j &amp;&amp; pivot &lt; nums[j]) j--;
            if (i &lt; j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i &lt;= r; i++) {
            if (nums[i] &lt; pivot) {
                swap(nums, l++, i);
            } else if (nums[i] &gt; pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i &lt; j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n &lt;= 1) return false;
        int i = n - 1;
        while (i - 1 &gt;= 0 &amp;&amp; nums[i - 1] &gt;= nums[i]) {
            i--;
        }
        if (i &lt;= 0) return false;
        for (int j = n - 1; j &gt;= i; j--) {
            if (nums[j] &gt; nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }
<A NAME="1"></A>
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match34-1.html#1',3,'match34-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 13;
        int seed2 = 131;
        int h1 = 0</B></FONT>, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i &lt; k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 &lt;&lt; 32) | ((long) h2 &lt;&lt; 32 &gt;&gt;&gt; 32);

        for (int i = k; i &lt; s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 &lt;&lt; 32) | ((long) h2 &lt;&lt; 32 &gt;&gt;&gt; 32);
        }

        return ans;
    }

    public static long stringHash(String s) {
        int h1 = 0;
        int h2 = 0;
        int seed1 = 13;
        int seed2 = 131;

        for (int i = 0; i &lt; s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);
        }
        return ((long) h1 &lt;&lt; 32) | ((long) h2 &lt;&lt; 32 &gt;&gt;&gt; 32);
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i &lt; n; i++) {
            int k = next[i - 1];
            while (k &gt; 0 &amp;&amp; s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i &lt; n; i++) {
            while (j &gt; 0 &amp;&amp; p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    // a, b could be negative
    // remainder &gt;= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r &lt; 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List&lt;Integer&gt; negativeBase(int n, int base) {
        List&lt;Integer&gt; digits = new ArrayList&lt;&gt;();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        while (b &gt; 0) {
            if ((b &amp; 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b &gt;&gt;= 1;
        }
        return res;
    }

    // Tested by leetcode 1163
    public static int[] suffixSort(int[] s) {
        int n = s.length;
        int[] count = new int[n], t;
        int[] SA = new int[n], nSA = new int[n];
        int[] rank = new int[n], nRank = new int[n];

        Integer[] tempArray = new Integer[n];
        for (int x = 0; x &lt; n; x++) tempArray[x] = x;
        Arrays.sort(tempArray, (a, b) -&gt; Integer.compare(s[a], s[b])); // NOTE: comparison might overflow!!!
        for (int x = 0; x &lt; n; x++) SA[x] = tempArray[x];

        int i, k;
        for (rank[SA[0]] = 0, i = 1; i &lt; n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k &lt; n &amp;&amp; rank[SA[n - 1]] &lt; n - 1; k &lt;&lt;= 1) {
            for (i = 0; i &lt; n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i &gt;= 0; i--) if (SA[i] &gt;= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i &lt; n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i &lt; n; i++) {
                nRank[SA[i]] = (SA[i] + k &gt;= n ||
                        SA[i - 1] + k &gt;= n ||
                        rank[SA[i]] != rank[SA[i - 1]] ||
                        rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
        return SA;
    }

    public static int min(int... values) {
        int ret = values[0];
        for (int v : values) ret = Math.min(ret, v);
        return ret;
    }

    public static int max(int... values) {
        int ret = values[0];
        for (int v : values) ret = Math.max(ret, v);
        return ret;
    }

    private static double getDistanceSum(double x, double y, double[][] points) {
        double ret = 0;
        for (int i = 0; i &lt; points.length; ++i) {
            double dx = points[i][0] - x;
            double dy = points[i][1] - y;
            ret += Math.sqrt(dx * dx + dy * dy);
        }
        return ret;
    }

    // Tested by Leetcode 1515
    public static double getGeometricMedian(double[][] points) {
        int n = points.length;
        double eps = 1e-8;

        double lx = Double.MAX_VALUE;
        double rx = Double.MIN_VALUE;
        double ly = Double.MAX_VALUE;
        double ry = Double.MIN_VALUE;
        double resX = 0;
        double resY = 0;
        for (int i = 0; i &lt; n; i++) {
            double x = points[i][0];
            double y = points[i][1];
            resX += x;
            resY += y;
            lx = Math.min(lx, x);
            rx = Math.max(rx, x);
            ly = Math.min(ly, y);
            ry = Math.max(ry, y);
        }
        resX /= n;
        resY /= n;
        double delta = Math.max((rx - lx), (ry - ly));
        double resDist = getDistanceSum(resX, resY, points);
        lx = resX - 2.0 * delta;
        rx = resX + 2.0 * delta;
        ly = resY - 2.0 * delta;
        ry = resY + 2.0 * delta;
        for (; delta &gt; eps; delta /= 2.0) {
            for (double x = lx; x &lt;= rx; x += delta) {
                for (double y = ly; y &lt;= ry; y += delta) {
                    double d = getDistanceSum(x, y, points);
                    if (d &lt; resDist) {
                        resDist = d;
                        resX = x;
                        resY = y;
                    }
                }
            }
            lx = resX - delta;
            rx = resX + delta;
            ly = resY - delta;
            ry = resY + delta;
        }
        return resDist;
    }

    public static void preprocessCombination(long[][] C, long MOD) {
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt;= i &amp;&amp; j &lt; n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
    }

    public static void preprocessCombination(long[][] C) {
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt;= i &amp;&amp; j &lt; n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
    }

    public static void preprocessPermutation(long[][] P, long MOD) {
        int m = P.length;
        int n = P[0].length;
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt;= i &amp;&amp; j &lt; n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1) % MOD;
            }
        }
    }

    // P(m, n) % MOD, m &gt;= n
    // O(M - N)
    public static long computePermutation(int m, int n, long MOD) {
        if (m == 0 || n == 0) return 1L;
        long ret = 1;
        for (long i = m; i &gt;= (m - n) + 1; i--) {
            ret = ret * i % MOD;
        }
        return ret;
    }

    // C(m, n) % MOD, m &gt;= n
    // O(M + N)
    // Tested by https://ac.nowcoder.com/acm/contest/5758/D
    public static long computeCombination(int m, int n, long MOD) {
        if (m == 0 || n == 0 || m == n) return 1L;
        return computePermutation(m, m, MOD)
                * inverse(computePermutation(n, n, MOD), MOD) % MOD
                * inverse(computePermutation(m - n, m - n, MOD), MOD) % MOD;
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    public static long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public static long inverse(long a, long MOD) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }
}

class Combination {
    long[] factorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        factorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i &lt;= maxSize; i++) factorial[i] = factorial[i - 1] * i % MOD;
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m &gt;= n
    // O(logN)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
        return factorial[m] * inverse(factorial[m - n]) % MOD;
    }

    // m &gt;= n
    // O(logN)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
    }
}

class Fraction {
    long n, d;

    public Fraction(long n, long d) {
        long g = gcd(n, d);
        this.n = n / g;
        this.d = d / g;
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(numerator, denominator);
        this.n = numerator / g;
        this.d = denominator / g;
    }
<A NAME="2"></A>
    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    <FONT color="#77bfc7"><A HREF="javascript:ZweiFrames('match34-1.html#2',3,'match34-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}
}

class UnionFind {
    private int[] parent;
    private int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i &lt; n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if</B></FONT> (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
<A NAME="3"></A>            parent[x] = px;
            x = next;
        }
        <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match34-1.html#3',3,'match34-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;</B></FONT>
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }
}

class Trie {
    private static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
    }

    private TrieNode root = new TrieNode();

    public void insert(String word) {
        TrieNode cur = root;
        for (int i = 0; i &lt; word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) {
                cur.next[c] = new TrieNode();
            }
            cur = cur.next[c];
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i &lt; word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) return false;
            cur = cur.next[c];
            if (cur.isWord) return true;
        }
        return false;
    }
}

class Pair {
    long x, y;

    public Pair(long x, long y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object obj) {
        Pair pt = (Pair) obj;
        return (x == pt.x) &amp;&amp; (y == pt.y);
    }

    @Override
    public int hashCode() {
        //return (int) (x ^ (y * 31));
        long bits = x ^ (y * 31);
        return (((int) bits) ^ ((int) (bits &gt;&gt; 32)));
    }
}

class SegmentTree {
    private int size;
    private int[][] data;

    // 0 ... n - 1
    public SegmentTree(int n) {
        this.size = n;
        this.data = new int[this.size * 4][2];
        build(0, 0, n - 1);
    }


    int[] getMin(int[] a, int[] b) {
        if (a[0] &lt; b[0]) return a;
        else if (a[0] &gt; b[0]) return b;
        else {
            if (a[1] &lt; b[1]) return a;
            else return b;
        }
    }

    private void build(int x, int l, int r) {
        if (l == r) {
            data[x][0] = 0;
            data[x][1] = l; //// TODO
            return;
        }

        int m = (l + r) &gt;&gt; 1;
        build(x * 2 + 1, l, m);
        build(x * 2 + 2, m + 1, r);
        data[x] = getMin(data[x * 2 + 1], data[x * 2 + 2]); //// TODO
    }

    public void update(int pos, int value) {
        update(0, 0, size - 1, pos, value);
    }

    private void update(int x, int l, int r, int pos, int value) {
        if (l == r) {
            data[x] = new int[]{value, l}; //// TODO
            return;
        }
        int m = (l + r) &gt;&gt; 1;
        if (pos &lt;= m)
            update(x * 2 + 1, l, m, pos, value);
        else
            update(x * 2 + 2, m + 1, r, pos, value);
        data[x] = getMin(data[x * 2 + 1], data[x * 2 + 2]); //// TODO
    }

    public int[] query(int queryL, int queryR) {
        return query(0, 0, size - 1, queryL, queryR);
    }

    private int[] query(int x, int l, int r, int queryL, int queryR) {
        if (queryL &lt;= l &amp;&amp; r &lt;= queryR) {
            return data[x];
        }

        int m = (l + r) &gt;&gt; 1;
        if (queryR &lt;= m)
            return query(x * 2 + 1, l, m, queryL, queryR);
        else if (m + 1 &lt;= queryL)
            return query(x * 2 + 2, m + 1, r, queryL, queryR);
        else
            return getMin(query(x * 2 + 1, l, m, queryL, m),
                    query(x * 2 + 2, m + 1, r, m + 1, queryR)); //// TODO
    }
}

class BinaryIndexTree {
    private int[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 .. n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new int[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, int value) {
        while (k &lt;= n) {
            c[k] += value;
            k += (k &amp; (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public int getSum(int k) {
        int sum = 0;
        while (k &gt; 0) {
            sum += c[k];
            k -= (k &amp; (k ^ (k - 1)));
        }
        return sum;
    }
}

class ListIndex {
    BinaryIndexTree bit;
    int n;

    public ListIndex(int n) {
        this.n = n;
        bit = new BinaryIndexTree(n);
        for (int i = 1; i &lt;= n; i++) bit.add(i, 1);
    }

    // 0 .. n - 1
    public void removeFixedIndex(int fixedIndex) {
        bit.add(fixedIndex + 1, -1);
    }

    // 0 ... n - 1;
    public int getDynamicIndex(int fixedIndex) {
        return bit.getSum(fixedIndex + 1) - 1;
    }

    // 0 ... n - 1;
    public int getFixedIndex(int dyIndex) {
        int low = 1;
        int high = n + 1;
        while (low &lt; high) {
            int mid = (low + high) / 2;
            if (bit.getSum(mid) &lt; dyIndex + 1) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low - 1;
    }

    public int dynamicSize() {
        return bit.getSum(this.n);
    }

    public int fixedSize() {
        return n;
    }
}

abstract class Calculator&lt;T&gt; {
    abstract protected T parseNumber(String s);

    abstract protected T add(T a, T b);

    abstract protected T minus(T a, T b);

    abstract protected T multiply(T a, T b);

    abstract protected T divide(T a, T b);


    public T calculate(String s, T defaultValue) {
        if (s == null) {
            return defaultValue;
        }
        s = s.replaceAll(&quot;\\s+&quot;, &quot;&quot;);
        if (s.length() == 0) {
            return defaultValue;
        }
        pos = 0;
        return parse(s, defaultValue);
    }

    private int pos;

    private T parse(String s, T defaultValue) {
        Stack&lt;T&gt; st = new Stack&lt;&gt;();
        T cur = defaultValue;
        char sign = '+';

        while (pos &lt; s.length()) {
            if (s.charAt(pos) == '(') {
                // skip the '('
                pos++;
                cur = parse(s, defaultValue);
                // skip the ')'
                pos++;
            } else {
                StringBuilder number = new StringBuilder();
                while (pos &lt; s.length()) {
                    char ch = s.charAt(pos);
                    if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '(' || ch == ')') {
                        break;
                    }
                    number.append(ch);
                    pos++;
                }
                cur = parseNumber(number.toString());
            }
            if (sign == '+') st.push(cur);
            if (sign == '-') st.push(minus(defaultValue, cur));
            if (sign == '*') st.push(multiply(st.pop(), cur));
            if (sign == '/') st.push(divide(st.pop(), cur));

            if (pos &gt;= s.length() || s.charAt(pos) == ')') break;
            sign = s.charAt(pos++);
        }
        T ans = defaultValue;
        while (!st.empty()) {
            ans = add(ans, st.pop());
        }
        return ans;
    }
}

// Including topological sort.
// Tested by Leetcode 1203
class Graph&lt;E&gt; {
    Map&lt;E, List&lt;E&gt;&gt; adj = new HashMap&lt;&gt;();

    public void addNode(E node) {
        adj.computeIfAbsent(node, k -&gt; new ArrayList&lt;&gt;());
    }

    // directed edge x -&gt; y
    public void link(E x, E y) {
        adj.computeIfAbsent(x, k -&gt; new ArrayList&lt;&gt;()).add(y);
    }

    public List&lt;E&gt; getChildren(E x) {
        return adj.getOrDefault(x, new ArrayList&lt;&gt;());
    }

    public Set&lt;E&gt; getAllNodes() {
        return adj.keySet();
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -&gt; y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List&lt;Node&gt; as the result.
    public List&lt;E&gt; topologicalSort() {
        Map&lt;E, Integer&gt; vst = new HashMap&lt;&gt;();
        List&lt;E&gt; result = new ArrayList&lt;&gt;();
        for (E x : getAllNodes()) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(E root, Map&lt;E, Integer&gt; vst, List&lt;E&gt; result) {
        if (vst.getOrDefault(root, 0) == TEMPORARY) { // found cycle
            return false;
        }

        if (vst.getOrDefault(root, 0) == PERMANENT) {
            return true;
        }
        vst.put(root, TEMPORARY);
        for (E child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst.put(root, PERMANENT);
        return true;
    }
}

class Dijkstra {
    public static class Edge {
        int to;
        int w;

        public Edge(int to, int w) {
            this.to = to;
            this.w = w;
        }
    }

    public Map&lt;Integer, List&lt;Edge&gt;&gt; adj = new HashMap&lt;&gt;();

    public void link(int x, int y, int w) {
        adj.computeIfAbsent(x, k -&gt; new ArrayList&lt;&gt;()).add(new Edge(y, w));
    }

    public Map&lt;Integer, Integer&gt; shortestPath(int src) {
        Map&lt;Integer, Integer&gt; dist = new HashMap&lt;&gt;();
        Set&lt;Integer&gt; vst = new HashSet&lt;&gt;();

        PriorityQueue&lt;Edge&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; Integer.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist.put(src, 0);

        while (true) {
            while (!q.isEmpty() &amp;&amp; vst.contains(q.peek().to)) {
                q.poll();
            }
            if (q.isEmpty()) break;

            Edge cur = q.poll();
            int u = cur.to;
            int w = cur.w;
            vst.add(u);
            if (adj.containsKey(u)) {
                for (Edge e : adj.get(u)) {
                    if (!vst.contains(e.to) &amp;&amp; (!dist.containsKey(e.to) || dist.get(e.to) &gt; w + e.w)) {
                        dist.put(e.to, w + e.w);
                        q.add(new Edge(e.to, w + e.w));
                    }
                }
            }
        }
        return dist;
    }
}

class EulerPath&lt;T, E&gt; {
    private Map&lt;T, List&lt;Object[]&gt;&gt; adj = new HashMap&lt;T, List&lt;Object[]&gt;&gt;();
    private Map&lt;T, Integer&gt; curr = new HashMap&lt;T, Integer&gt;();
    private Set&lt;E&gt; vst = new HashSet&lt;E&gt;();
    private List&lt;E&gt; result = new ArrayList&lt;E&gt;();

    // 1. For directed graph, each edge has unique edgeId
    // 2. For undirected graph, you need to call link() twice with the same
    // edgeId, as below:
    // addEdge(x, y, 1);
    // addEdge(y, x, 1);
    public void addEdge(T x, T y, E edgeId) {
        if (!adj.containsKey(x)) {
            adj.put(x, new ArrayList&lt;Object[]&gt;());
        }
        adj.get(x).add(new Object[]{y, edgeId});
    }

    private void dfs(T x) {
        if (adj.containsKey(x)) {
            while (curr.get(x) &lt; adj.get(x).size()) {
                int index = curr.get(x);
                curr.put(x, index + 1);
                Object[] edge = adj.get(x).get(index);
                T y = (T) edge[0];
                E edgeId = (E) edge[1];
                if (vst.contains(edgeId)) {
                    continue;
                }
                vst.add(edgeId);
                dfs(y);
                result.add(edgeId);
            }
        }
    }

    public List&lt;E&gt; getEulerPath() {
        T start = adj.keySet().iterator().next();
        return getEulerPath(start);
    }

    public List&lt;E&gt; getEulerPath(T start) {
        for (T x : adj.keySet()) {
            curr.put(x, 0);
        }
        dfs(start);
        Collections.reverse(result);
        return result;
    }
}

class MultiTreeSet&lt;E&gt; {
    TreeMap&lt;E, Integer&gt; data;
    int sz;

    public MultiTreeSet() {
        data = new TreeMap&lt;&gt;();
        sz = 0;
    }

    public void add(E e) {
        data.put(e, data.getOrDefault(e, 0) + 1);
        sz++;
    }

    public boolean remove(Object o) {
        if (data.containsKey(o)) {
            data.put((E) o, data.getOrDefault(o, 0) - 1);
            sz--;

            if (data.get(o) == 0) {
                data.remove(o);
            }
            return true;
        } else {
            return false;
        }
    }

    public boolean contains(E e) {
        return data.containsKey(e);
    }

    public E first() {
        return data.firstKey();
    }

    public E last() {
        return data.lastKey();
    }

    public int size() {
        return sz;
    }

    public List&lt;E&gt; getAll() {
        List&lt;E&gt; list = new ArrayList&lt;&gt;();
        for (Map.Entry&lt;E, Integer&gt; entry : data.entrySet()) {
            E e = entry.getKey();
            int count = entry.getValue();
            for (int i = 0; i &lt; count; i++) {
                list.add(e);
            }
        }
        return list;
    }
}

class TreapSet&lt;E&gt; {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator&lt;? super E&gt; comparator;
    private Node root;

    public TreapSet(Comparator&lt;? super E&gt; comparator) {
        this.comparator = comparator;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null)
            y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root)
            root = y;
        else if (x == x.pnt.left)
            x.pnt.left = y;
        else
            x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null)
            y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root)
            root = y;
        else if (x == x.pnt.right)
            x.pnt.right = y;
        else
            x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp &lt; 0)
                x = x.left;
            else if (cmp &gt; 0)
                x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) &lt; 0)
            p.left = x;
        else
            p.right = x;
        while ((p = x.pnt) != null &amp;&amp; p.priority &lt; x.priority) {
            if (p.left == x)
                rotateRight(p);
            else
                rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp &lt; 0)
                x = x.left;
            else if (cmp &gt; 0)
                x = x.right;
            else {
                if (--(x.count) &gt; 0)
                    return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null &amp;&amp; x.right.priority &gt; x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp &lt; 0)
                x = x.left;
            else if (cmp &gt; 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        return size() - lowerCount(key) - count(key);
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index &lt;= t)
                p = p.left;
            else {
                if ((index -= t + p.count) &lt;= 0)
                    break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp &lt; 0)
                x = x.left;
            else if (cmp &gt; 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public boolean contains(E key) {
        return count(key) &gt; 0;
    }
}

class BlockList {
    private static final int MAX_BLOCK_SIZE = 300;

    class Block {
        List&lt;Integer&gt; data = new ArrayList&lt;&gt;();
        int min = 0;

        public Block(int n) {
            for (int i = 0; i &lt; n; i++) {
                data.add(0);
            }
        }

        void update(int index, int value) {
            data.set(index, value);
            min = Integer.MAX_VALUE;
            for (int v : data) {
                min = Math.min(min, v);
            }
        }

        int query(int startIndex, int value) {
            if (min &gt; value) return -1;
            for (int i = startIndex; i &lt; data.size(); i++) {
                if (value &gt;= data.get(i)) return i;
            }
            return -1;
        }

        int query(int startIndex, int endIndex, int value) {
            if (min &gt; value) return -1;
            for (int i = startIndex; i &lt; endIndex; i++) {
                if (value &gt;= data.get(i)) return i;
            }
            return -1;
        }
    }

    List&lt;Block&gt; blocks;

    public BlockList(int n) {
        blocks = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i += MAX_BLOCK_SIZE) {
            int end = Math.min(i + MAX_BLOCK_SIZE, n);
            Block block = new Block(end - i);
            blocks.add(block);
        }
    }

    public int query(int index, int value) {
        int blockIndex = index / MAX_BLOCK_SIZE;
        int pos = index % MAX_BLOCK_SIZE;

        int t = blocks.get(blockIndex).query(pos, value);
        if (t &gt;= 0) return blockIndex * MAX_BLOCK_SIZE + t;

        for (int i = blockIndex + 1; i &lt; blocks.size(); i++) {
            t = blocks.get(i).query(0, value);
            if (t &gt;= 0) return i * MAX_BLOCK_SIZE + t;
        }
        for (int i = 0; i &lt; blockIndex; i++) {
            t = blocks.get(i).query(0, value);
            if (t &gt;= 0) return i * MAX_BLOCK_SIZE + t;
        }

        t = blocks.get(blockIndex).query(0, pos, value);
        if (t &gt;= 0) return blockIndex * MAX_BLOCK_SIZE + t;
        return -1;
    }

    public void update(int index, int value) {
        blocks.get(index / MAX_BLOCK_SIZE).update(index % MAX_BLOCK_SIZE, value);
    }
}

class ArraySum {
    int[] sum;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        sum = new int[nums.length + 1];
        for (int i = 1; i &lt;= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public int getSum(int l, int r) {
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;

    // nums index starts from 0
    public TwoDArraySum(int[][] nums) {
        int m = nums.length;
        int n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i &lt;= m; i++) {
            for (int j = 1; j &lt;= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 &lt;= x2 and y1 &lt;= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtil {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        int n1 = array.length;
        for (int i = 0; i &lt; n1; i++) {
            int n2 = array[i].length;
            for (int j = 0; j &lt; n2; j++) {
                array[i][j] = defaultValue;
            }
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        int n1 = array.length;
        for (int i = 0; i &lt; n1; i++) {
            int n2 = array[i].length;
            for (int j = 0; j &lt; n2; j++) {
                int n3 = array[i][j].length;
                for (int k = 0; k &lt; n3; k++) {
                    array[i][j][k] = defaultValue;
                }
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        int n1 = array.length;
        for (int i = 0; i &lt; n1; i++) {
            int n2 = array[i].length;
            for (int j = 0; j &lt; n2; j++) {
                int n3 = array[i][j].length;
                for (int k = 0; k &lt; n3; k++) {
                    int n4 = array[i][j][k].length;
                    for (int l = 0; l &lt; n4; l++) {
                        array[i][j][k][l] = defaultValue;
                    }
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        int n1 = array.length;
        for (int i = 0; i &lt; n1; i++) {
            int n2 = array[i].length;
            for (int j = 0; j &lt; n2; j++) {
                int n3 = array[i][j].length;
                for (int k = 0; k &lt; n3; k++) {
                    int n4 = array[i][j][k].length;
                    for (int l = 0; l &lt; n4; l++) {
                        int n5 = array[i][j][k][l].length;
                        for (int x = 0; x &lt; n5; x++) {
                            array[i][j][k][l][x] = defaultValue;
                        }
                    }
                }
            }
        }
    }
}

class DataGen {
    public static Random random = new Random(0);

    public static String genString(int length) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; length; i++) {
            char ch = (char) (random.nextInt(26) + 'a');
            sb.append(ch);
        }
        return sb.toString();
    }

    public static int[] genIntegers(int n, int bound) {
        int[] nums = new int[n];
        for (int i = 0; i &lt; n; i++) {
            nums[i] = random.nextInt(bound);
        }
        return nums;
    }
}

public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007;
    private static final int UNSET = -13131;
    private static final int[][] DIR = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};


    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {
        UnionFind uf = new UnionFind(n + 10);
        Arrays.sort(edgeList, (x, y) -&gt; Integer.compare(x[2], y[2]));

        int[][] q = new int[queries.length][4];
        for (int i = 0; i &lt; queries.length; i++) {
            q[i][0] = queries[i][0];
            q[i][1] = queries[i][1];
            q[i][2] = queries[i][2];
            q[i][3] = i;
        }
        Arrays.sort(q, (x, y) -&gt; Integer.compare(x[2], y[2]));
        
        boolean[] ans = new boolean[queries.length];
        for (int i = 0, j = 0; i &lt; q.length; i++) {
            int x = q[i][0];
            int y = q[i][1];
            int limit = q[i][2];
            int index = q[i][3];
            
            while (j &lt; edgeList.length &amp;&amp; edgeList[j][2] &lt; limit) {
                uf.union(edgeList[j][0], edgeList[j][1]);
                j++;
            }
            ans[index] = uf.find(x) == uf.find(y);
        }
        return ans;
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */

        //int[][] boxes = {{2, 4}, {2, 5}, {3, 1}, {3, 2}, {3, 7}, {3, 1}, {4, 4}, {1, 3}, {5, 2}};
        //int portsCount = 5, maxBoxes = 5, maxWeight = 7;
        //System.out.println(new Solution().boxDelivering(boxes, portsCount, maxBoxes, maxWeight));

        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + &quot;ms&quot;);
    }
}
</PRE>

</BODY>
</HTML>
