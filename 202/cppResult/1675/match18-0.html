<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>710_chejianchao.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>710_chejianchao.cpp</CENTER></H3><HR>
<PRE>
// vector&lt;int&gt; position;
// struct cmp{
//     bool operator ()(pair&lt;int, int&gt; &amp;a, pair&lt;int, int&gt; &amp;b) {
//         return position[a.second] - position[a.first] &lt; position[b.second] - position[b.first];
<A NAME="0"></A>//     }
// };

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match18-1.html#0',3,'match18-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>class Solution {
public:
    int maxDistance(vector&lt;int&gt;&amp; position, int m) {
        // position = pos;
        sort(position.begin(), position.end());
        int l = 1, r = position.back();
<A NAME="1"></A>        int ans = 0;
        while(l &lt; r) {
            int mid = (l + r) / 2;
            int cnt = 1, base = 0;</B></FONT><FONT color="#f63526"><A HREF="javascript:ZweiFrames('match18-1.html#1',3,'match18-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>
            for(int i = 1; i &lt; position.size(); ++i) {
                if(position[i] - position[base] &gt;= mid) {
                    ++cnt;
                    base = i;
                }
            }
            if(cnt &gt;= m){
                l = mid + 1;
                ans = max(ans, mid);
            }
            else
                r = mid;
        }
        return ans;
        // int mid = l;
        // int cnt = 1, base = 0;
        // for(int i = 1; i &lt; position.size(); ++i) {
        //     if(position[i] - position[base] &gt;= mid) {
        //         ++cnt;
        //         base = i;
        //     }
        // }
        // if(cnt &gt;= m) return l;
        // return l - 1;
//         priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, cmp &gt; pq;
//         pq.push({ 0, position.size() - 1});
//         --m;
//         int ans = INT_MAX;
//         cout&lt;&lt;&quot;begin&quot;&lt;&lt;endl;
//         while(m-- &gt; 0) {
//             auto p = pq.top(); pq.pop();
//             int l = p.first, r = p.second;
//             ans = min(ans, position[r] - position[l]);
//             int mid = (position[l] + position[r]) / 2;
//             if(l + 1 == r) continue;
//             // int li = l, ri = l;
//             // while(li &lt; ri) {
//             //     int mi = (li + ri) / 2;
//             //     if(position[mi] &lt;= mid)
//             //         li = mi + 1;
//             //     else
//             //         ri = mi;
//             // }
//             // cout&lt;&lt;li&lt;&lt;&quot; &quot;&lt;&lt;endl;
//             // int idx = li;
//             int idx = upper_bound(position.begin() + l, position.begin() + r + 1, mid) - position.begin();
//             cout&lt;&lt;idx&lt;&lt;&quot; &quot;&lt;&lt;position[idx]&lt;&lt;endl;
//             int mn = min(position[r] - position[idx], position[idx] - position[l]);
//             int mn2= min(position[r] - position[idx - 1], position[idx - 1] - position[l]);
//             if(mn2 &gt; mn)
//                 --idx;
//             if(l &lt; idx) {
                
//                 pq.push({l, idx});
//             }
//             if(r &gt; idx) {
//                 pq.push({idx, r});
//             }
//         }
//         return ans;
    }
};</B></FONT>
</PRE>
</BODY>
</HTML>
