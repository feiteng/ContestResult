<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>450_xianglaniunan.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>450_xianglaniunan.java</CENTER></H3><HR>
<PRE>
import java.awt.Point;
import java.io.*;
import java.util.*;
import java.math.BigInteger;
import java.util.Map.*;

<A NAME="3"></A>
public class Solution{

    <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match32-0.html#3',2,'match32-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>public int ways(String[] pizza, int k) 
    {
        int m = pizza.length, n = pizza[0].length();
        long[][][] f = new long[m][n][k + 1];
        for(long[][] fr : f)
        {
            for(long[] ff : fr)
            {
                Arrays.fill(ff, -1);
            }
        }
        char[][] board = new char[m][n];
        for(int i = 0; i &lt; m; i++)
        {
            board[i] = pizza[i].toCharArray();
        }

        int mod = 1_000_000_</B></FONT>007;
        long ans = dfs(0, 0, board, k, f);
<A NAME="0"></A>        return (int)(ans % mod);
    }   

    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match32-0.html#0',2,'match32-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>long dfs(int x, int y, char[][] board, int k, long[][][] f)
    {
        if(f[x][y][k] &gt;= 0) return f[x][y][k];
        int m = board.length, n = board[0].length;
        if(k == 1)
        {
            int r = 0;
            for(int i = x; i &lt; m; i++)
            {
                for(int j = y;  j &lt; n; j++)
<A NAME="1"></A>                {</B></FONT>
                    if(board[i][j] == 'A') r++;
                }
            <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match32-0.html#1',2,'match32-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
            return r &gt; 0 ? 1 : 0;
        }

        long re = 0;
        for(int i = x + 1; i &lt; m; i++)
<A NAME="2"></A>        {
            if(cut1(board, x, i, y))
            {</B></FONT>
                re += <FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match32-0.html#2',2,'match32-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>dfs(i, y, board, k - 1, f);
            }
        }

        for(int j = y + 1; j &lt; n; j++)
        {
            if(cut2(board, y, j, x))
            {</B></FONT>
                re += dfs(x, j, board, k - 1, f);
<A NAME="4"></A>            }   
        }        
        return f[x][y][k] = re;
    <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match32-0.html#4',2,'match32-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    boolean cut1(char[][]board, int x, int cut, int y)
    {
        int sum2 = 0;
        int sum1 = 0;
        int m =board.length;
        int n =board[0].length;
        for(int i = x; i &lt; m; i++)
        {
            for(int j = y; j &lt; n; j++)
<A NAME="5"></A>            {</B></FONT>
                int value =board[i][j] == 'A' ? 1 : 0;
                if(i &lt; cut) sum1 += value;
                else sum2 += value<FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match32-0.html#5',2,'match32-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>;
            }
        }
        return sum1 &gt; 0 &amp;&amp; sum2 &gt; 0;
    }

    boolean cut2(char[][]board, int y, int cut, int x)
    {
        int sum2 = 0;
        int sum1 = 0;
        int m =board.length;
        int n =board[0].length;

        for(int i = x; i &lt; m; i++)
        {
            for(int j = y; j &lt; n; j++)
            {</B></FONT>
                int value =board[i][j] == 'A' ? 1 : 0;
                if(j &lt; cut) sum1 += value;
                else sum2 += value;
            }
        }
        return sum1 &gt; 0 &amp;&amp; sum2 &gt; 0;
    }



    public static class FastIO implements AutoCloseable
    {
        private InputStream in;
        private final byte[] buffer = new byte[1024];
        private int read = 0;
        private int length = 0;
        private PrintWriter out;
        private PrintWriter err;
        private boolean autoFlush = false;
        private boolean outFlush = false;
        private boolean autoOutFlush = true;

        public FastIO() {
            this(System.in, System.out, System.err);
        }

        public FastIO(InputStream in, PrintStream out, PrintStream err) {
            this.in = in;
            this.out = new PrintWriter(out, false);
            this.err = new PrintWriter(err, false);
        }

        public final void setInputStream(InputStream in) {
            this.in = in;
        }

        public final void setInputStream(File in) {
            try {
                this.in = new FileInputStream(in);
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        public final void setOutputStream(PrintStream out) {
            this.out = new PrintWriter(out, false);
        }

        public final void setOutputStream(File out) {
            try {
                this.out = new PrintWriter(new FileOutputStream(out), false);
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        public final void setErrorStream(PrintStream err) {
            this.err = new PrintWriter(err, false);
        }

        public final void setErrorStream(File err) {
            try {
                this.err = new PrintWriter(new FileOutputStream(err), false);
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        public final void setAutoFlush(boolean flush) {
            autoFlush = flush;
        }

        public final void setAutoOutFlush(boolean flush) {
            autoOutFlush = flush;
        }

        private boolean hasNextByte() {
            if (read &lt; length) return true;
            read = 0;
            try {
                length = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            return length &gt; 0;
        }

        private byte readByte() {
            if (hasNextByte()) return buffer[read++];
            throw new NoSuchElementException();
        }

        private boolean readNewLine() {
            if (hasNextByte()) {
                if (buffer[read] == '\r') {
                    ++ read;
                    if (hasNextByte() &amp;&amp; buffer[read] == '\n') ++ read;
                    return true;
                }
                if (buffer[read] == '\n') {
                    ++ read;
                    return true;
                }
            }
            return false;
        }

        private static boolean isPrintableChar(byte c) {
            return 32 &lt; c || c &lt; 0;
        }

        private static boolean isNumber(int c) {
            return '0' &lt;= c &amp;&amp; c &lt;= '9';
        }

        public final boolean hasNext() {
            while (hasNextByte() &amp;&amp; !isPrintableChar(buffer[read])) read++;
            return hasNextByte();
        }

        public final char nextChar() {
            if (outFlush) {
                outFlush = false;
                flush();
            }
            byte b = readByte();
            if ((b &amp; 0x80) == 0) return (char)b;
            if ((b &amp; 0x20) == 0) return (char)((b &amp; 0x1F) &lt;&lt; 6 | (readByte() &amp; 0x3F));
            return (char)((b &amp; 0xF) &lt;&lt; 12 | (readByte() &amp; 0x3F) &lt;&lt; 6 | (readByte() &amp; 0x3F));
        }

        public final char[] nextChars() {
            return next().toCharArray();
        }

        public final char[] nextChars(char around) {
            return (around + next() + around).toCharArray();
        }

        public final char[][] nextChars(int height) {
            char[][] ret = new char[height][];
            for (int i = 0;i &lt; ret.length;++ i) ret[i] = nextChars();
            return ret;
        }

        public final char[][] nextChars(int height, char around) {
            char[][] ret = new char[height + 2][];
            for (int i = 1;i &lt;= height;++ i) ret[i] = nextChars(around);
            Arrays.fill(ret[0] = new char[ret[1].length], around);
            Arrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);
            return ret;
        }

        public final String next() {
            if (outFlush) {
                outFlush = false;
                flush();
            }
            if (!hasNext()) throw new NoSuchElementException();
            StringBuilder sb = new StringBuilder();
            do sb.append(nextChar()); while(hasNextByte() &amp;&amp; isPrintableChar(buffer[read]));
            return sb.toString();
        }

        public final String nextLine() {
            if (outFlush) {
                outFlush = false;
                flush();
            }
            StringBuilder sb = new StringBuilder();
            while(!readNewLine()) sb.append(nextChar());
            return sb.toString();
        }

        public final long nextLong() {
            if (outFlush) {
                outFlush = false;
                flush();
            }
            if (!hasNext()) throw new NoSuchElementException();
            long n = 0;
            try {
                byte b = readByte();
                if (b == '-') {
                    while(isNumber(b = readByte())) n = n * 10 + '0' - b;
                    return n;
                } else if (!isNumber(b)) throw new NumberFormatException();
                do n = n * 10 + b - '0'; while(isNumber(b = readByte()));
                return n;
            } catch (NoSuchElementException e) {
                return n;
            }
        }

        public final int nextInt() {
            if (outFlush) {
                outFlush = false;
                flush();
            }
            if (!hasNext()) throw new NoSuchElementException();
            int n = 0;
            try {
                byte b = readByte();
                if (b == '-') {
                    while(isNumber(b = readByte())) n = n * 10 + '0' - b;
                    return n;
                } else if (!isNumber(b)) throw new NumberFormatException();
                do n = n * 10 + b - '0'; while(isNumber(b = readByte()));
                return n;
            } catch (NoSuchElementException e) {
                return n;
            }
        }

        public final double nextDouble() {
            return Double.parseDouble(next());
        }

        public final int[] nextInt(int width) {
            int[] ret = new int[width];
            for (int i = 0;i &lt; width;++ i) ret[i] = nextInt();
            return ret;
        }

        public final int[] nextInts() {
            return nextInts(&quot; &quot;);
        }

        public final int[] nextInts(String parse) {
            String[] get = nextLine().split(parse);
            int[] ret = new int[get.length];
            for (int i = 0;i &lt; ret.length;++ i) ret[i] = Integer.valueOf(get[i]);
            return ret;
        }

        public final long[] nextLong(int width) {
            long[] ret = new long[width];
            for (int i = 0;i &lt; width;++ i) ret[i] = nextLong();
            return ret;
        }

        public final long[] nextLongs() {
            return nextLongs(&quot; &quot;);
        }

        public final long[] nextLongs(String parse) {
            String[] get = nextLine().split(parse);
            long[] ret = new long[get.length];
            for (int i = 0;i &lt; ret.length;++ i) ret[i] = Long.valueOf(get[i]);
            return ret;
        }

        public final int[][] nextInt(int width, int height) {
            int[][] ret = new int[height][width];
            for (int i = 0, j;i &lt; height;++ i) for (j = 0;j &lt; width;++ j) ret[i][j] = nextInt();
            return ret;
        }

        public final long[][] nextLong(int width, int height) {
            long[][] ret = new long[height][width];
            for (int i = 0, j;i &lt; height;++ i) for (j = 0;j &lt; width;++ j) ret[j][i] = nextLong();
            return ret;
        }

        public final boolean[] nextBoolean(char T) {
            char[] s = next().toCharArray();
            boolean[] ret = new boolean[s.length];
            for (int i = 0;i &lt; ret.length;++ i) ret[i] = s[i] == T;
            return ret;
        }

        public final boolean[][] nextBoolean(char T, int height) {
            boolean[][] ret = new boolean[height][];
            for (int i = 0;i &lt; ret.length;++ i) {
                char[] s = next().toCharArray();
                ret[i] = new boolean[s.length];
                for (int j = 0;j &lt; ret[i].length;++ j) ret[i][j] = s[j] == T;
            }
            return ret;
        }

        public final Point nextPoint() {
            return new Point(nextInt(), nextInt());
        }

        public final Point[] nextPoint(int width) {
            Point[] ret = new Point[width];
            for (int i = 0;i &lt; width;++ i) ret[i] = nextPoint();
            return ret;
        }

        @Override
        protected void finalize() throws Throwable {
            try {
                super.finalize();
            } finally {
                in.close();
                out.close();
                err.close();
            }
        }

        public final boolean print(boolean b) {
            out.print(b);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return b;
        }

        public final Object print(boolean b, Object t, Object f) {
            return b ? print(t) : print(f);
        }

        public final char print(char c) {
            out.print(c);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return c;
        }

        public final char[] print(char[] s) {
            out.print(s);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return s;
        }

        public final double print(double d) {
            out.print(d);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return d;
        }

        public final double print(double d, int length) {
            if (d &lt; 0) {
                out.print('-');
                d = -d;
            }
            d += Math.pow(10, -length) / 2;
            out.print((long)d);
            out.print('.');
            d -= (long)d;
            for (int i = 0;i &lt; length;++ i) {
                d *= 10;
                out.print((int)d);
                d -= (int)d;
            }
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return d;
        }

        public final float print(float f) {
            out.print(f);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return f;
        }

        public final int print(int i) {
            out.print(i);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return i;
        }

        public final long print(long l) {
            out.print(l);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return l;
        }

        public final Object print(Object obj) {
            if (obj != null &amp;&amp; obj.getClass().isArray()) {
                if (obj instanceof boolean[][]) print(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof byte[][]) print(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof short[][]) print(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof int[][]) print(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof long[][]) print(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof float[][]) print(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof double[][]) print(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof char[][]) print(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof Object[][]) print(obj, &quot;\n&quot;, &quot; &quot;);
                else print(obj, &quot; &quot;);
            } else {
                out.print(obj);
                if (autoFlush) flush();
                else outFlush = autoOutFlush;
            }
            return obj;
        }

        public final String print(String s) {
            out.print(s);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return s;
        }

        public final Object print(Object array, String... parse) {
            print(array, 0, parse);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return array;
        }

        private final Object print(Object array, int check, String... parse) {
            if (check &gt;= parse.length) {
                if (array != null &amp;&amp; array.getClass().isArray()) throw new IllegalArgumentException(&quot;not equal dimension&quot;);
                print(array);
                return array;
            }
            String str = parse[check];
            if (array instanceof Object[]) {
                Object[] obj = (Object[]) array;
                if (obj.length == 0) return array;
                print(obj[0], check + 1, parse);
                for (int i = 1;i &lt; obj.length;++ i) {
                    print(str);
                    print(obj[i], check + 1, parse);
                }
                return array;
            }
            if (array instanceof Collection) {
                Iterator&lt;?&gt; iter = ((Collection&lt;?&gt;)array).iterator();
                if (!iter.hasNext()) return array;
                print(iter.next(), check + 1, parse);
                while(iter.hasNext()) {
                    print(str);
                    print(iter.next(), check + 1, parse);
                }
                return array;
            }
            if (!array.getClass().isArray()) throw new IllegalArgumentException(&quot;not equal dimension&quot;);
            if (check != parse.length - 1) throw new IllegalArgumentException(&quot;not equal dimension&quot;);
            if (array instanceof boolean[]) {
                boolean[] obj = (boolean[]) array;
                if (obj.length == 0) return array;
                print(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    print(str);
                    print(obj[i]);
                }
            } else if (array instanceof byte[]) {
                byte[] obj = (byte[]) array;
                if (obj.length == 0) return array;
                print(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    print(str);
                    print(obj[i]);
                }
                return array;
            } else if (array instanceof short[]) {
                short[] obj = (short[]) array;
                if (obj.length == 0) return array;
                print(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    print(str);
                    print(obj[i]);
                }
            } else if (array instanceof int[]) {
                int[] obj = (int[]) array;
                if (obj.length == 0) return array;
                print(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    print(str);
                    print(obj[i]);
                }
            } else if (array instanceof long[]) {
                long[] obj = (long[]) array;
                if (obj.length == 0) return array;
                print(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    print(str);
                    print(obj[i]);
                }
            } else if (array instanceof float[]) {
                float[] obj = (float[]) array;
                if (obj.length == 0) return array;
                print(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    print(str);
                    print(obj[i]);
                }
            } else if (array instanceof double[]) {
                double[] obj = (double[]) array;
                if (obj.length == 0) return array;
                print(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    print(str);
                    print(obj[i]);
                }
            } else if (array instanceof char[]) {
                char[] obj = (char[]) array;
                if (obj.length == 0) return array;
                print(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    print(str);
                    print(obj[i]);
                }
            } else throw new AssertionError();
            return array;
        }

        public final Object[] print(String parse, Object... args) {
            print(args[0]);
            for (int i = 1;i &lt; args.length;++ i) {
                print(parse);
                print(args[i]);
            }
            return args;
        }

        public final Object[] printf(String format, Object... args) {
            out.printf(format, args);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return args;
        }

        public final Object printf(Locale l, String format, Object... args) {
            out.printf(l, format, args);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return args;
        }

        public final void println() {
            out.println();
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
        }

        public final boolean println(boolean b) {
            out.println(b);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return b;
        }

        public final Object println(boolean b, Object t, Object f) {
            return b ? println(t) : println(f);
        }

        public final char println(char c) {
            out.println(c);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return c;
        }

        public final char[] println(char[] s) {
            out.println(s);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return s;
        }

        public final double println(double d) {
            out.println(d);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return d;
        }

        public final double println(double d, int length) {
            print(d, length);
            println();
            return d;
        }

        public final float println(float f) {
            out.println(f);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return f;
        }

        public final int println(int i) {
            out.println(i);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return i;
        }

        public final long println(long l) {
            out.println(l);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return l;
        }

        public final Object println(Object obj) {
            print(obj);
            println();
            return obj;
        }

        public final String println(String s) {
            out.println(s);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return s;
        }

        public final Object println(Object array, String... parse) {
            print(array, parse);
            println();
            return array;
        }

        public final boolean debug(boolean b) {
            err.print(b);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return b;
        }

        public final Object debug(boolean b, Object t, Object f) {
            return b ? debug(t) : debug(f);
        }

        public final char debug(char c) {
            err.print(c);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return c;
        }

        public final char[] debug(char[] s) {
            err.print(s);
            return s;
        }

        public final double debug(double d) {
            err.print(d);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return d;
        }

        public final double debug(double d, int length) {
            if (d &lt; 0) {
                err.print('-');
                d = -d;
            }
            d += Math.pow(10, -length) / 2;
            err.print((long)d);
            err.print('.');
            d -= (long)d;
            for (int i = 0;i &lt; length;++ i) {
                d *= 10;
                err.print((int)d);
                d -= (int)d;
            }
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return d;
        }

        public final float debug(float f) {
            err.print(f);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return f;
        }

        public final int debug(int i) {
            err.print(i);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return i;
        }

        public final long debug(long l) {
            err.print(l);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return l;
        }

        public final Object debug(Object obj) {
            if (obj != null &amp;&amp; obj.getClass().isArray()) {
                if (obj instanceof boolean[][]) debug(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof byte[][]) debug(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof short[][]) debug(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof int[][]) debug(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof long[][]) debug(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof float[][]) debug(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof double[][]) debug(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof char[][]) debug(obj, &quot;\n&quot;, &quot; &quot;);
                else if (obj instanceof Object[][]) debug(obj, &quot;\n&quot;, &quot; &quot;);
                else debug(obj, &quot; &quot;);
            } else {
                err.print(obj);
                if (autoFlush) flush();
                else outFlush = autoOutFlush;
            }
            return obj;
        }

        public final String debug(String s) {
            err.print(s);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return s;
        }

        public final Object debug(Object array, String... parse) {
            debug(array, 0, parse);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return array;
        }

        private final Object debug(Object array, int check, String... parse) {
            if (check &gt;= parse.length) {
                if (array != null &amp;&amp; array.getClass().isArray()) throw new IllegalArgumentException(&quot;not equal dimension&quot;);
                debug(array);
                return array;
            }
            String str = parse[check];
            if (array instanceof Object[]) {
                Object[] obj = (Object[]) array;
                if (obj.length == 0) return array;
                debug(obj[0], check + 1, parse);
                for (int i = 1;i &lt; obj.length;++ i) {
                    debug(str);
                    debug(obj[i], check + 1, parse);
                }
                return array;
            }
            if (array instanceof Collection) {
                Iterator&lt;?&gt; iter = ((Collection&lt;?&gt;)array).iterator();
                if (!iter.hasNext()) return array;
                debug(iter.next(), check + 1, parse);
                while(iter.hasNext()) {
                    debug(str);
                    debug(iter.next(), check + 1, parse);
                }
                return array;
            }
            if (!array.getClass().isArray()) throw new IllegalArgumentException(&quot;not equal dimension&quot;);
            if (check != parse.length - 1) throw new IllegalArgumentException(&quot;not equal dimension&quot;);
            if (array instanceof boolean[]) {
                boolean[] obj = (boolean[]) array;
                if (obj.length == 0) return array;
                debug(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    debug(str);
                    debug(obj[i]);
                }
            } else if (array instanceof byte[]) {
                byte[] obj = (byte[]) array;
                if (obj.length == 0) return array;
                debug(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    debug(str);
                    debug(obj[i]);
                }
                return array;
            } else if (array instanceof short[]) {
                short[] obj = (short[]) array;
                if (obj.length == 0) return array;
                debug(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    debug(str);
                    debug(obj[i]);
                }
            } else if (array instanceof int[]) {
                int[] obj = (int[]) array;
                if (obj.length == 0) return array;
                debug(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    debug(str);
                    debug(obj[i]);
                }
            } else if (array instanceof long[]) {
                long[] obj = (long[]) array;
                if (obj.length == 0) return array;
                debug(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    debug(str);
                    debug(obj[i]);
                }
            } else if (array instanceof float[]) {
                float[] obj = (float[]) array;
                if (obj.length == 0) return array;
                debug(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    debug(str);
                    debug(obj[i]);
                }
            } else if (array instanceof double[]) {
                double[] obj = (double[]) array;
                if (obj.length == 0) return array;
                debug(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    debug(str);
                    debug(obj[i]);
                }
            } else if (array instanceof char[]) {
                char[] obj = (char[]) array;
                if (obj.length == 0) return array;
                debug(obj[0]);
                for (int i = 1;i &lt; obj.length;++ i) {
                    debug(str);
                    debug(obj[i]);
                }
            } else throw new AssertionError();
            return array;
        }

        public final Object[] debug(String parse, Object... args) {
            debug(args[0]);
            for (int i = 1;i &lt; args.length;++ i) {
                debug(parse);
                debug(args[i]);
            }
            return args;
        }

        public final Object[] debugf(String format, Object... args) {
            err.printf(format, args);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return args;
        }

        public final Object debugf(Locale l, String format, Object... args) {
            err.printf(l, format, args);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return args;
        }

        public final void debugln() {
            err.println();
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
        }

        public final boolean debugln(boolean b) {
            err.println(b);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return b;
        }

        public final Object debugln(boolean b, Object t, Object f) {
            return b ? debugln(t) : debugln(f);
        }

        public final char debugln(char c) {
            err.println(c);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return c;
        }

        public final char[] debugln(char[] s) {
            err.println(s);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return s;
        }

        public final double debugln(double d) {
            err.println(d);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return d;
        }

        public final double debugln(double d, int length) {
            debug(d, length);
            debugln();
            return d;
        }

        public final float debugln(float f) {
            err.println(f);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return f;
        }

        public final int debugln(int i) {
            err.println(i);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return i;
        }

        public final long debugln(long l) {
            err.println(l);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return l;
        }

        public final Object debugln(Object obj) {
            debug(obj);
            debugln();
            return obj;
        }

        public final String debugln(String s) {
            err.println(s);
            if (autoFlush) flush();
            else outFlush = autoOutFlush;
            return s;
        }

        public final Object debugln(Object array, String... parse) {
            debug(array, parse);
            debugln();
            return array;
        }

        public final void flush() {
            out.flush();
            err.flush();
            outFlush = false;
        }

        @Override
        public final void close() {
            out.close();
            err.close();
        }
    }
    


    public enum BoundType {
        CLOSED, OPEN;
    }

    public static class Range&lt;C&gt; implements Serializable{

        private static final long serialVersionUID = -4702828934863023392L;
        protected C lower;
        protected C upper;
        protected BoundType lowerType;
        protected BoundType upperType;
        private Comparator&lt;? super C&gt; comparator;

        protected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {
            this(lower, lowerType, upper, upperType, null);
        }

        protected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator&lt;? super C&gt; comparator) {
            this.lower = lower;
            this.upper = upper;
            this.lowerType = lowerType;
            this.upperType = upperType;
            this.comparator = comparator;
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; range(C lower, BoundType lowerType, C upper, BoundType upperType) {
            if (lower != null &amp;&amp; upper != null) {
                int comp = lower.compareTo(upper);
                if (comp &gt; 0) return new Range&lt;C&gt;(null, BoundType.CLOSED, null, BoundType.CLOSED);
                else if (comp == 0 &amp;&amp; (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range&lt;C&gt;(null, BoundType.CLOSED, null, BoundType.CLOSED);
            }
            return new Range&lt;C&gt;(lower, lowerType, upper, upperType);
        }

        public static &lt;C&gt; Range&lt;C&gt; range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator&lt;? super C&gt; comparator) {
            if (lower != null &amp;&amp; upper != null) {
                int comp = comparator.compare(lower, upper);
                if (comp &gt; 0) return new Range&lt;C&gt;(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);
                else if (comp == 0 &amp;&amp; (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range&lt;C&gt;(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);
            }
            return new Range&lt;C&gt;(lower, lowerType, upper, upperType, comparator);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; all() {
            return range((C)null, BoundType.OPEN, null, BoundType.OPEN);
        }

        public static &lt;C&gt; Range&lt;C&gt; all(Comparator&lt;? super C&gt; comparator) {
            return range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; atMost(C upper) {
            return range(null, BoundType.OPEN, upper, BoundType.CLOSED);
        }

        public static &lt;C&gt; Range&lt;C&gt; atMost(C upper, Comparator&lt;? super C&gt; comparator) {
            return range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; lessThan(C upper) {
            return range(null, BoundType.OPEN, upper, BoundType.OPEN);
        }

        public static &lt;C&gt; Range&lt;C&gt; lessThan(C upper, Comparator&lt;? super C&gt; comparator) {
            return range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; downTo(C upper, BoundType boundType) {
            return range(null, BoundType.OPEN, upper, boundType);
        }

        public static &lt;C&gt; Range&lt;C&gt; downTo(C upper, BoundType boundType, Comparator&lt;? super C&gt; comparator) {
            return range(null, BoundType.OPEN, upper, boundType, comparator);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; atLeast(C lower) {
            return range(lower, BoundType.CLOSED, null, BoundType.OPEN);
        }

        public static &lt;C&gt; Range&lt;C&gt; atLeast(C lower, Comparator&lt;? super C&gt; comparator) {
            return range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; greaterThan(C lower) {
            return range(lower, BoundType.OPEN, null, BoundType.OPEN);
        }

        public static &lt;C&gt; Range&lt;C&gt; greaterThan(C lower, Comparator&lt;? super C&gt; comparator) {
            return range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; upTo(C lower, BoundType boundType) {
            return range(lower, boundType, null, BoundType.OPEN);
        }

        public static &lt;C&gt; Range&lt;C&gt; upTo(C lower, BoundType boundType, Comparator&lt;? super C&gt; comparator) {
            return range(lower, boundType, null, BoundType.OPEN, comparator  );
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; open(C lower, C upper) {
            return range(lower, BoundType.OPEN, upper, BoundType.OPEN);
        }

        public static &lt;C&gt; Range&lt;C&gt; open(C lower, C upper, Comparator&lt;? super C&gt; comparator) {
            return range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; openClosed(C lower, C upper) {
            return range(lower, BoundType.OPEN, upper, BoundType.CLOSED);
        }

        public static &lt;C&gt; Range&lt;C&gt; openClosed(C lower, C upper, Comparator&lt;? super C&gt; comparator) {
            return range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; closedOpen(C lower, C upper) {
            return range(lower, BoundType.CLOSED, upper, BoundType.OPEN);
        }

        public static &lt;C&gt; Range&lt;C&gt; closedOpen(C lower, C upper, Comparator&lt;? super C&gt; comparator) {
            return range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; closed(C lower, C upper) {
            return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);
        }

        public static &lt;C&gt; Range&lt;C&gt; closed(C lower, C upper, Comparator&lt;? super C&gt; comparator) {
            return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; singleton(C value) {
            return range(value, BoundType.CLOSED, value, BoundType.CLOSED);
        }

        public static &lt;C&gt; Range&lt;C&gt; singleton(C value, Comparator&lt;? super C&gt; comparator) {
            return range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; empty() {
            return range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);
        }

        public static &lt;C&gt; Range&lt;C&gt; empty(Comparator&lt;? super C&gt; comparator) {
            return range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; Range&lt;C&gt; encloseAll(Iterable&lt;C&gt; values) {
            C lower = values.iterator().next();
            C upper = lower;
            for (C i : values) {
                if (lower.compareTo(i) &gt; 0) lower = i;
                if (upper.compareTo(i) &lt; 0) upper = i;
            }
            return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);
        }

        public static &lt;C&gt; Range&lt;C&gt; encloseAll(Iterable&lt;C&gt; values, Comparator&lt;? super C&gt; comparator) {
            C lower = values.iterator().next();
            C upper = lower;
            for (C i : values) {
                if (comparator.compare(lower, i) &gt; 0) lower = i;
                if (comparator.compare(upper, i) &lt; 0) upper = i;
            }
            return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);
        }

        protected int compareLower(C value) {
            return compareLower(value, BoundType.CLOSED);
        }

        protected int compareLower(C value, BoundType boundType) {
            return compareLower(lower, lowerType, value, boundType);
        }

        protected int compareLower(C lower, BoundType lowerType, C value) {
            return compareLower(lower, lowerType, value, BoundType.CLOSED);
        }

        protected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {
            if (lower == null) return value == null ? 0 : -1;
            else if (value == null) return 1;
            int compare;
            if (comparator == null) {
                @SuppressWarnings(&quot;unchecked&quot;)
                Comparable&lt;C&gt; comp = (Comparable&lt;C&gt;)lower;
                compare = comp.compareTo(value);
            } else compare = comparator.compare(lower, value);
            if (compare == 0) {
                if (lowerType == BoundType.CLOSED) -- compare;
                if (boundType == BoundType.CLOSED) ++ compare;
            }
            return compare;
        }

        protected int compareUpper(C value) {
            return compareUpper(value, BoundType.CLOSED);
        }

        protected int compareUpper(C value, BoundType boundType) {
            return compareUpper(upper, upperType, value, boundType);
        }

        protected int compareUpper(C upper, BoundType upperType, C value) {
            return compareUpper(upper, upperType, value, BoundType.CLOSED);
        }

        protected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {
            if (upper == null) return value == null ? 0 : 1;
            if (value == null) return -1;
            int compare;
            if (comparator == null) {
                @SuppressWarnings(&quot;unchecked&quot;)
                Comparable&lt;C&gt; comp = (Comparable&lt;C&gt;)upper;
                compare = comp.compareTo(value);
            } else compare = comparator.compare(upper, value);
            if (compare == 0) {
                if (upperType == BoundType.CLOSED) ++ compare;
                if (boundType == BoundType.CLOSED) -- compare;
            }
            return compare;
        }

        public boolean hasLowerBound() {
            return lower != null;
        }

        public C lowerEndpoint() {
            if (hasLowerBound()) return lower;
            throw new IllegalStateException();
        }

        public BoundType lowerBoundType() {
            if (hasLowerBound()) return lowerType;
            throw new IllegalStateException();
        }

        public boolean hasUpperBound() {
            return upper != null;
        }

        public C upperEndpoint() {
            if (hasUpperBound()) return upper;
            throw new IllegalStateException();
        }

        public BoundType upperBoundType() {
            if (hasUpperBound()) return upperType;
            throw new IllegalStateException();
        }


        public boolean isEmpty() {
            return lower == null &amp;&amp; upper == null &amp;&amp; lowerType == BoundType.CLOSED;
        }


        public boolean isLess(C value) {
            return isLess(value, BoundType.CLOSED);
        }

        protected boolean isLess(C value, BoundType boundType) {
            return compareLower(value, boundType) &gt; 0;
        }


        public boolean isGreater(C value) {
            return isGreater(value, BoundType.CLOSED);
        }

        private boolean isGreater(C value, BoundType boundType) {
            return compareUpper(value, boundType) &lt; 0;
        }

        
        public boolean contains(C value) {
            return !isLess(value) &amp;&amp; !isGreater(value) &amp;&amp; !isEmpty();
        }

        public boolean containsAll(Iterable&lt;? extends C&gt; values) {
            for (C i : values) if (!contains(i)) return false;
            return true;
        }

        
        public boolean encloses(Range&lt;C&gt; other) {
            return !isLess(other.lower, other.lowerType) &amp;&amp; !isGreater(other.upper, other.upperType);
        }

        
        public boolean isConnected(Range&lt;C&gt; other) {
            if (this.isEmpty() || other.isEmpty()) return false;
            C lower, upper;
            BoundType lowerType, upperType;
            if (isLess(other.lower, other.lowerType)) {
                lower = other.lower;
                lowerType = other.lowerType;
            } else {
                lower = this.lower;
                lowerType = this.lowerType;
            }
            if (isGreater(other.upper, other.upperType)) {
                upper = other.upper;
                upperType = other.upperType;
            } else {
                upper = this.upper;
                upperType = this.upperType;
            }
            if (lower == null || upper == null) return true;
            int comp = compareLower(lower, lowerType, upper, upperType);
            return comp &lt;= 0;
        }
        
        public Range&lt;C&gt; intersection(Range&lt;C&gt; connectedRange) {
            if (this.isEmpty() || connectedRange.isEmpty()) {
                if (comparator == null) return new Range&lt;C&gt;(null, BoundType.CLOSED, null, BoundType.CLOSED);
                return empty(comparator);
            }
            C lower, upper;
            BoundType lowerType, upperType;
            if (isLess(connectedRange.lower, connectedRange.lowerType)) {
                lower = connectedRange.lower;
                lowerType = connectedRange.lowerType;
            } else {
                lower = this.lower;
                lowerType = this.lowerType;
            }
            if (isGreater(connectedRange.upper, connectedRange.upperType)) {
                upper = connectedRange.upper;
                upperType = connectedRange.upperType;
            } else {
                upper = this.upper;
                upperType = this.upperType;
            }
            if (comparator == null) {
                return new Range&lt;C&gt;(lower, lowerType, upper, upperType);
            }
            return range(lower, lowerType, upper, upperType, comparator);
        }

        
        public Range&lt;C&gt; span(Range&lt;C&gt; other) {
            if (other.isEmpty()) return new Range&lt;C&gt;(lower, lowerType, upper, upperType);
            C lower, upper;
            BoundType lowerType, upperType;
            if (isLess(other.lower, other.lowerType)) {
                lower = this.lower;
                lowerType = this.lowerType;
            } else {
                lower = other.lower;
                lowerType = other.lowerType;
            }
            if (isGreater(other.upper, other.upperType)) {
                upper = this.upper;
                upperType = this.upperType;
            } else {
                upper = other.upper;
                upperType = other.upperType;
            }
            return new Range&lt;C&gt;(lower, lowerType, upper, upperType, comparator);
        }

       
        public static &lt;C&gt; List&lt;Range&lt;C&gt;&gt; scheduling(List&lt;Range&lt;C&gt;&gt; ranges) {
            PriorityQueue&lt;Range&lt;C&gt;&gt; pq = new PriorityQueue&lt;Range&lt;C&gt;&gt;((l, r) -&gt; l.compareUpper(r.upper, r.upperType));
            List&lt;Range&lt;C&gt;&gt; ret = new ArrayList&lt;&gt;();
            Range&lt;C&gt; last = pq.poll();
            if (pq.isEmpty()) return ret;
            ret.add(last);
            while(!pq.isEmpty()) {
                Range&lt;C&gt; tmp = pq.poll();
                if (tmp.compareLower(last.upper, last.upperType) &gt; 0) {
                    ret.add(tmp);
                    last = tmp;
                }
            }
            return ret;
        }

        @Override
        public boolean equals(Object object) {
            if (this == object) return true;
            if (object instanceof Range) {
                @SuppressWarnings(&quot;unchecked&quot;)
                Range&lt;C&gt; comp = (Range&lt;C&gt;) object;
                return compareLower(comp.lower, comp.lowerType) == 0 &amp;&amp; compareUpper(comp.upper, comp.upperType) == 0 &amp;&amp; lowerType == comp.lowerType &amp;&amp; upperType == comp.upperType;
            }
            return false;
        }

        @Override
        public int hashCode() {
            if (lower == null &amp;&amp; upper == null) return 0;
            else if (lower == null) return upper.hashCode();
            else if (upper == null) return lower.hashCode();
            return lower.hashCode() ^ upper.hashCode();
        }

        @Override
        public String toString() {
            if (isEmpty()) return &quot;()&quot;;
            return (lowerType == BoundType.OPEN ? &quot;(&quot; : &quot;[&quot;) + (lower == null ? &quot;&quot; : lower.toString()) + &quot;..&quot; + (upper == null ? &quot;&quot; : upper.toString()) + (upperType == BoundType.OPEN ? &quot;)&quot; : &quot;]&quot;);
        }
    }

    

    public static class IterableRange&lt;C&gt; extends Range&lt;C&gt; implements Iterable&lt;C&gt;{

        private static final long serialVersionUID = 9065915259748260688L;
        protected UnaryOperator&lt;C&gt; func;

        protected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator&lt;C&gt; func) {
            super(lower, lowerType, upper, upperType);
            this.func = func;
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; IterableRange&lt;C&gt; range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator&lt;C&gt; func) {
            if (lower == null || upper == null) return new IterableRange&lt;C&gt;(null, BoundType.CLOSED, null, BoundType.CLOSED, func);
            int comp = lower.compareTo(upper);
            if (comp &gt; 0) return new IterableRange&lt;C&gt;(null, BoundType.CLOSED, null, BoundType.CLOSED, func);
            else if (comp == 0 &amp;&amp; (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange&lt;C&gt;(null, BoundType.CLOSED, null, BoundType.CLOSED, func);
            return new IterableRange&lt;C&gt;(lower, lowerType, upper, upperType, func);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; IterableRange&lt;C&gt; open(C lower, C upper, UnaryOperator&lt;C&gt; func) {
            if (lower == null) return new IterableRange&lt;C&gt;(null, BoundType.CLOSED, null, BoundType.CLOSED, func);
            return range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; IterableRange&lt;C&gt; openClosed(C lower, C upper, UnaryOperator&lt;C&gt; func) {
            if (lower == null) return new IterableRange&lt;C&gt;(null, BoundType.CLOSED, null, BoundType.CLOSED, func);
            return range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; IterableRange&lt;C&gt; closedOpen(C lower, C upper, UnaryOperator&lt;C&gt; func) {
            return range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; IterableRange&lt;C&gt; closed(C lower, C upper, UnaryOperator&lt;C&gt; func) {
            return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);
        }

        public static &lt;C extends Comparable&lt;? super C&gt;&gt; IterableRange&lt;C&gt; singleton(C value, UnaryOperator&lt;C&gt; func) {
            return range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);
        }

        protected class Iter implements Iterator&lt;C&gt; {
            C now;
            Iter() {
                now = lower;
            }
            @Override
            public final boolean hasNext() {
                return !isGreater(now);
            }

            @Override
            public final C next() {
                C ret = now;
                now = func.apply(now);
                return ret;
            }

            @Override
            public final void remove() {
                throw new UnsupportedOperationException();
            }
        }

        protected class EmptyIter implements Iterator&lt;C&gt; {

            @Override
            public boolean hasNext() {
                return false;
            }

            @Override
            public C next() {
                return null;
            }

            @Override
            public final void remove() {
                throw new UnsupportedOperationException();
            }

        }

        @Override
        public Iterator&lt;C&gt; iterator() {
            return lower == null || upper == null ? new EmptyIter() : new Iter();
        }

        public int getDistance() {
            C check = upper;
            int ret = 0;
            while (lower != check) {
                check = func.apply(check);
                ++ ret;
            }
            return ret;
        }
    }

    public static class IntRange extends IterableRange&lt;Integer&gt;{

        private static final long serialVersionUID = 5623995336491967216L;
        private final boolean useFastIter;

        private static class Next implements UnaryOperator&lt;Integer&gt; {

            @Override
            public Integer apply(Integer value) {
                return value + 1;
            }
        }

        protected IntRange() {
            super(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());
            useFastIter = true;
        }

        protected IntRange(UnaryOperator&lt;Integer&gt; func) {
            super(null, BoundType.CLOSED, null, BoundType.CLOSED, func);
            useFastIter = false;
        }

        protected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {
            super(lower, lowerType, upper, upperType, new Next());
            useFastIter = true;
        }

        protected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator&lt;Integer&gt; func) {
            super(lower, lowerType, upper, upperType, func);
            useFastIter = false;
        }

        public static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {
            if (lower &gt; upper) return new IntRange();
            if (lowerType == BoundType.OPEN) ++ lower;
            if (upperType == BoundType.OPEN) -- upper;
            return new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);
        }

        public static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator&lt;Integer&gt; func) {
            if (lower &gt; upper) return new IntRange(func);
            if (lowerType == BoundType.OPEN) ++ lower;
            if (upperType == BoundType.OPEN) -- upper;
            return new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);
        }

        public static IntRange open(int lower, int upper) {
            return range(lower, BoundType.OPEN, upper, BoundType.OPEN);
        }

        public static IntRange open(int lower, int upper, UnaryOperator&lt;Integer&gt; func) {
            return range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);
        }

        public static IntRange open(int upper) {
            return range(0, BoundType.CLOSED, upper, BoundType.OPEN);
        }

        public static IntRange open(int upper, UnaryOperator&lt;Integer&gt; func) {
            return range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);
        }

        public static IntRange openClosed(int lower, int upper) {
            return range(lower, BoundType.OPEN, upper, BoundType.CLOSED);
        }

        public static IntRange openClosed(int lower, int upper, UnaryOperator&lt;Integer&gt; func) {
            return range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);
        }

        public static IntRange closedOpen(int lower, int upper) {
            return range(lower, BoundType.CLOSED, upper, BoundType.OPEN);
        }

        public static IntRange closedOpen(int lower, int upper, UnaryOperator&lt;Integer&gt; func) {
            return range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);
        }

        public static IntRange closed(int lower, int upper) {
            return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);
        }

        public static IntRange closed(int lower, int upper, UnaryOperator&lt;Integer&gt; func) {
            return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);
        }

        public static IntRange closed(int upper) {
            return range(0, BoundType.CLOSED, upper, BoundType.CLOSED);
        }

        public static IntRange closed(int upper, UnaryOperator&lt;Integer&gt; func) {
            return range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);
        }

        public static IntRange singleton(int value) {
            return range(value, BoundType.CLOSED, value, BoundType.CLOSED);
        }

        public static IntRange singleton(int value, UnaryOperator&lt;Integer&gt; func) {
            return range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);
        }

        private class FastIter implements Iterator&lt;Integer&gt; {
            int now;
            public FastIter() {
                now = lower;
            }
            @Override
            public final boolean hasNext() {
                return now &lt;= upper;
            }

            @Override
            public final Integer next() {
                return now++;
            }

            @Override
            public final void remove() {
                throw new UnsupportedOperationException();
            }
        }

        private class Iter implements Iterator&lt;Integer&gt; {
            int now;
            public Iter() {
                now = lower;
            }
            @Override
            public final boolean hasNext() {
                return now &lt;= upper;
            }

            @Override
            public final Integer next() {
                int ret = now;
                now = func.apply(now);
                return ret;
            }

            @Override
            public final void remove() {
                throw new UnsupportedOperationException();
            }
        }

        @Override
        public Iterator&lt;Integer&gt; iterator() {
            return lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();
        }

        @Override
        public int getDistance() {
            int ret = upper - lower;
            if (upperType == BoundType.CLOSED) ++ ret;
            return ret;
        }

        public int getClosedLower() {
            return lower;
        }

        public int getOpenLower() {
            return lower - 1;
        }

        public int getClosedUpper() {
            return upperType == BoundType.CLOSED ? upper : upper - 1;
        }

        public int getOpenUpper() {
            return upperType == BoundType.CLOSED ? upper + 1 : upper;
        }

        public static List&lt;IntRange&gt; intScheduling(List&lt;IntRange&gt; ranges) {
            PriorityQueue&lt;IntRange&gt; pq = new PriorityQueue&lt;IntRange&gt;((l, r) -&gt; l.compareUpper(r.upper, r.upperType));
            pq.addAll(ranges);
            List&lt;IntRange&gt; ret = new ArrayList&lt;&gt;();
            if (pq.isEmpty()) return ret;
            IntRange last = pq.poll();
            ret.add(last);
            while(!pq.isEmpty()) {
                IntRange tmp = pq.poll();
                System.err.println(tmp);
                if (tmp.compareLower(last.upper, last.upperType) &gt; 0) {
                    ret.add(tmp);
                    last = tmp;
                }
            }
            return ret;
        }
    }


    public interface Associative&lt;T&gt; extends BinaryOperator&lt;T&gt;{

        public default T hyper(T element, int repeat) {
            if (repeat &lt; 1) throw new IllegalArgumentException(&quot;undefined operation&quot;);
            T ret = element;
            -- repeat;
            for (T mul = element;repeat &gt; 0;repeat &gt;&gt;= 1, mul = apply(mul, mul)) if ((repeat &amp; 1) != 0) ret = apply(ret, mul);
            return ret;
        }
    }

    public interface Inverse&lt;T&gt; extends BinaryOperator&lt;T&gt;{
        public T inverse(T element);
    }


    public interface Commutative&lt;T&gt; extends BinaryOperator&lt;T&gt;{

    }

    public interface Identity&lt;T&gt; extends BinaryOperator&lt;T&gt;{

        public T identity();
    }

    
    public interface Group&lt;T&gt; extends Monoid&lt;T&gt;, Inverse&lt;T&gt;{
       
        @Override
        public default T hyper(T element, int repeat) {
            T ret = identity();
            if (repeat &lt; 0) {
                repeat = -repeat;
                for (T mul = element;repeat &gt; 0;repeat &gt;&gt;= 1, mul = apply(mul, mul)) if ((repeat &amp; 1) != 0) ret = apply(ret, mul);
                return inverse(ret);
            }
            for (T mul = element;repeat &gt; 0;repeat &gt;&gt;= 1, mul = apply(mul, mul)) if ((repeat &amp; 1) != 0) ret = apply(ret, mul);
            return ret;
        }
    }

 
    public interface Monoid&lt;T&gt; extends Associative&lt;T&gt;, Identity&lt;T&gt; {
       
        @Override
        public default T hyper(T element, int repeat) {
            if (repeat &lt; 0) throw new IllegalArgumentException(&quot;undefined operation&quot;);
            T ret = identity();
            for (T mul = element;repeat &gt; 0;repeat &gt;&gt;= 1, mul = apply(mul, mul)) if ((repeat &amp; 1) != 0) ret = apply(ret, mul);
            return ret;
        }
    }

    public interface CommutativeMonoid&lt;T&gt; extends Monoid&lt;T&gt;, Commutative&lt;T&gt; {

    }

    
    public interface Abelian&lt;T&gt; extends Group&lt;T&gt;, CommutativeMonoid&lt;T&gt; {

    }

    public interface Semiring&lt;T, A extends CommutativeMonoid&lt;T&gt;, M extends Monoid&lt;T&gt;&gt; {
        public A getAddition();
        public M getMultiplication();
        public default T add(T left, T right) {
            return getAddition().apply(left, right);
        }

        public default T multiply(T left, T right) {
            return getMultiplication().apply(left, right);
        }

        public default T additiveIdentity() {
            return getAddition().identity();
        }

        public default T multipleIdentity() {
            return getMultiplication().identity();
        }

        public default int characteristic() {
            return 0;
        }
    }

  
    public interface Ring&lt;T, A extends Abelian&lt;T&gt;, M extends Monoid&lt;T&gt;&gt; extends Semiring&lt;T, A, M&gt;{

    }

   
    public interface CommutativeRing&lt;T, A extends Abelian&lt;T&gt;, M extends CommutativeMonoid&lt;T&gt;&gt; extends Ring&lt;T, A, M&gt;{

    }

   
    public interface IntegralDomain&lt;T, A extends Abelian&lt;T&gt;, M extends CommutativeMonoid&lt;T&gt;&gt; extends CommutativeRing&lt;T, A, M&gt;{
        public boolean isDivisible(T left, T right);
        public T divide(T left, T right);
    }

    public interface IntegrallyClosedDomain&lt;T, A extends Abelian&lt;T&gt;, M extends CommutativeMonoid&lt;T&gt;&gt; extends IntegralDomain&lt;T, A, M&gt;{

    }


    public interface GCDDomain&lt;T, A extends Abelian&lt;T&gt;, M extends CommutativeMonoid&lt;T&gt;&gt; extends IntegrallyClosedDomain&lt;T, A, M&gt;{
        public T gcd(T left, T right);
        public T lcm(T left, T right);
    }

    public static class PrimeElement&lt;T&gt; {
        public final T element;
        public PrimeElement(T element) {
            this.element = element;
        }
    }

    public interface MultiSet&lt;E&gt; extends Collection&lt;E&gt;{
        public int add(E element, int occurrences);
        public int count(Object element);
        public Set&lt;E&gt; elementSet();
        public boolean remove(Object element, int occurrences);
        public int setCount(E element, int count);
        public boolean setCount(E element, int oldCount, int newCount);
    }

    public interface UniqueFactorizationDomain&lt;T, A extends Abelian&lt;T&gt;, M extends CommutativeMonoid&lt;T&gt;&gt; extends GCDDomain&lt;T, A, M&gt;{
        public MultiSet&lt;PrimeElement&lt;T&gt;&gt; PrimeFactorization(T x);
    }

  
    public interface PrincipalIdealDomain&lt;T, A extends Abelian&lt;T&gt;, M extends CommutativeMonoid&lt;T&gt;&gt; extends UniqueFactorizationDomain&lt;T, A, M&gt; {

    }

    public interface EuclideanDomain&lt;T, A extends Abelian&lt;T&gt;, M extends CommutativeMonoid&lt;T&gt;&gt; extends PrincipalIdealDomain&lt;T, A, M&gt;{
        public T reminder(T left, T right);
    }

  
    public interface Field&lt;T, A extends Abelian&lt;T&gt;, M extends Abelian&lt;T&gt;&gt; extends EuclideanDomain&lt;T, A, M&gt;{
        @Override
        public default boolean isDivisible(T left, T right) {
            return !right.equals(additiveIdentity());
        }

        @Override
        public default T divide(T left, T right) {
            if (isDivisible(left, right)) throw new ArithmeticException(&quot;divide by Additive Identify&quot;);
            return multiply(left, getMultiplication().inverse(right));
        }

        @Override
        public default T reminder(T left, T right) {
            if (isDivisible(left, right)) throw new ArithmeticException(&quot;divide by Additive Identify&quot;);
            return additiveIdentity();
        }

        @Override
        public default T gcd(T left, T right) {
            return multipleIdentity();
        }

        @Override
        public default T lcm(T left, T right) {
            return multipleIdentity();
        }

        @Override
        public default MultiSet&lt;PrimeElement&lt;T&gt;&gt; PrimeFactorization(T x) {
            HashMultiSet&lt;PrimeElement&lt;T&gt;&gt; ret = HashMultiSet.create(1);
            ret.add(new PrimeElement&lt;T&gt;(x));
            return ret;
        }
    }

    public static class HashMultiSet&lt;E&gt; implements MultiSet&lt;E&gt;, Serializable{

        private static final long serialVersionUID = -8378919645386251159L;
        private final transient HashMap&lt;E, Integer&gt; map;
        private transient int size;

        private HashMultiSet() {
            map = new HashMap&lt;&gt;();
            size = 0;
        }

        private HashMultiSet(int distinctElements) {
            map = new HashMap&lt;&gt;(distinctElements);
            size = 0;
        }

        public static &lt;E&gt; HashMultiSet&lt;E&gt; create() {
            return new HashMultiSet&lt;&gt;();
        }

        public static &lt;E&gt; HashMultiSet&lt;E&gt; create(int distinctElements) {
            return new HashMultiSet&lt;&gt;(distinctElements);
        }

        public static &lt;E&gt; HashMultiSet&lt;E&gt; create(Iterable&lt;? extends E&gt; elements) {
            HashMultiSet&lt;E&gt; ret = new HashMultiSet&lt;&gt;();
            for (E i : elements) ret.map.compute(i, (v, e) -&gt; e == null ? 1 : ++e);
            return ret;
        }

        @Override
        public int size() {
            return size;
        }

        @Override
        public boolean isEmpty() {
            return size == 0;
        }

        @Override
        public boolean contains(Object o) {
            return map.containsKey(o);
        }

        private class Iter implements Iterator&lt;E&gt; {

            private final Iterator&lt;Entry&lt;E, Integer&gt;&gt; iter = map.entrySet().iterator();
            private E value;
            private int count = 0;

            @Override
            public boolean hasNext() {
                if (count &gt; 0) return true;
                if (iter.hasNext()) {
                    Entry&lt;E, Integer&gt; entry = iter.next();
                    value = entry.getKey();
                    count = entry.getValue();
                    return true;
                }
                return false;
            }

            @Override
            public E next() {
                -- count;
                return value;
            }

        }

        @Override
        public Iterator&lt;E&gt; iterator() {
            return new Iter();
        }

        @Override
        public Object[] toArray() {
            Object[] ret = new Object[size];
            int read = 0;
            for (Entry&lt;E, Integer&gt; i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());
            return ret;
        }

        @Override
        public &lt;T&gt; T[] toArray(T[] a) {
            Object[] src = toArray();
            if (a.length &lt; src.length) {
                @SuppressWarnings(&quot;unchecked&quot;)
                T[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());
                return ret;
            }
            System.arraycopy(src, 0, a, 0, src.length);
            return a;
        }

        @Override
        public boolean add(E e) {
            add(e, 1);
            return true;
        }

        @Override
        public boolean remove(Object o) {
            return remove(o, 1);
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; c) {
            boolean ret = true;
            for (Object i : c) ret |= contains(i);
            return ret;
        }

        @Override
        public boolean addAll(Collection&lt;? extends E&gt; c) {
            boolean ret = false;
            for (E i : c) ret |= add(i);
            return ret;
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; c) {
            boolean ret = false;
            for (Object i : c) ret |= remove(i);
            return ret;
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; c) {
            return removeAll(c);
        }

        @Override
        public void clear() {
            map.clear();
            size = 0;
        }

        @Override
        public int add(E element, int occurrences) {
            size += occurrences;
            return map.compute(element, (k, v) -&gt; v == null ? occurrences : v + occurrences) - occurrences;
        }

        @Override
        public int count(Object element) {
            return map.getOrDefault(element, 0);
        }

        @Override
        public Set&lt;E&gt; elementSet() {
            return map.keySet();
        }

        public Set&lt;Entry&lt;E, Integer&gt;&gt; entrySet() {
            return map.entrySet();
        }

        @Override
        public boolean remove(Object element, int occurrences) {
            try {
                @SuppressWarnings(&quot;unchecked&quot;)
                E put = (E) element;
                return map.compute(put, (k, v) -&gt; {
                    if (v == null) return null;
                    if (v &lt; occurrences) {
                        size -= v;
                        return null;
                    }
                    size -= occurrences;
                    return v - occurrences;
                }) != null;
            } catch (ClassCastException E) {
                return false;
            }
        }

        @Override
        public int setCount(E element, int count) {
            Integer ret = map.put(element, count);
            int ret2 = ret == null ? 0 : ret;
            size += count - ret2;
            return ret2;
        }

        @Override
        public boolean setCount(E element, int oldCount, int newCount) {
            boolean ret = map.replace(element, oldCount, newCount);
            if (ret) size += newCount - oldCount;
            return ret;
        }

    }

    public static class ModInteger extends Number implements Field&lt;ModInteger, Abelian&lt;ModInteger&gt;, Abelian&lt;ModInteger&gt;&gt;{

        private static final long serialVersionUID = -8595710127161317579L;
        private final int mod;
        private int num;

        private final Addition add;
        private final Multiplication mul;

        private class Addition implements Abelian&lt;ModInteger&gt; {

            @Override
            public ModInteger identity() {
                return new ModInteger(mod, 0);
            }

            @Override
            public ModInteger inverse(ModInteger element) {
                return new ModInteger(element, element.mod - element.num);
            }

            @Override
            public ModInteger apply(ModInteger left, ModInteger right) {
                return new ModInteger(left).addEqual(right);
            }
        }

        private class Multiplication implements Abelian&lt;ModInteger&gt; {

            @Override
            public ModInteger identity() {
                return new ModInteger(mod, 1);
            }

            @Override
            public ModInteger apply(ModInteger left, ModInteger right) {
                return new ModInteger(left).multiplyEqual(right);
            }

            @Override
            public ModInteger inverse(ModInteger element) {
                return new ModInteger(element, element.inverse(element.num));
            }

        }

        @Override
        public int characteristic() {
            return mod;
        }

        public ModInteger(int mod) {
            this.mod = mod;
            num = 0;
            add = new Addition();
            mul = new Multiplication();
        }

        public ModInteger(int mod, int num) {
            this.mod = mod;
            this.num = validNum(num);
            add = new Addition();
            mul = new Multiplication();
        }

        public ModInteger(ModInteger n) {
            mod = n.mod;
            num = n.num;
            add = n.add;
            mul = n.mul;
        }

        private ModInteger(ModInteger n, int num) {
            mod = n.mod;
            this.num = num;
            add = n.add;
            mul = n.mul;
        }

        private int validNum(int n) {
            n %= mod;
            if (n &lt; 0) n += mod;
            return n;
        }

        private int validNum(long n) {
            n %= mod;
            if (n &lt; 0) n += mod;
            return (int)n;
        }

        protected int inverse(int n) {
            int m = mod, u = 0, v = 1, t;
            while(n != 0) {
                t = m / n;
                m -= t * n;
                u -= t * v;
                if (m != 0) {
                    t = n / m;
                    n -= t * m;
                    v -= t * u;
                } else {
                    v %= mod;
                    if (v &lt; 0) v += mod;
                    return v;
                }
            }
            u %= mod;
            if (u &lt; 0) u += mod;
            return u;
        }

        public boolean isPrime(int n) {
            if ((n &amp; 1) == 0) return false; // 
            for (int i = 3, j = 8, k = 9;k &lt;= n;i += 2, k += j += 8) if (n % i == 0) return false;
            return true;
        }

        @Override
        public int intValue() {
            return num;
        }

        @Override
        public long longValue() {
            return num;
        }

        @Override
        public float floatValue() {
            return num;
        }

        @Override
        public double doubleValue() {
            return num;
        }

        protected ModInteger getNewInstance(ModInteger mod) {
            return new ModInteger(mod);
        }

        public ModInteger add(int n) {
            return getNewInstance(this).addEqual(n);
        }

        public ModInteger add(long n) {
            return getNewInstance(this).addEqual(n);
        }

        public ModInteger add(ModInteger n) {
            return getNewInstance(this).addEqual(n);
        }

        public ModInteger addEqual(int n) {
            num = validNum(num + n);
            return this;
        }

        public ModInteger addEqual(long n) {
            num = validNum(num + n);
            return this;
        }

        public ModInteger addEqual(ModInteger n) {
            if ((num += n.num) &gt;= mod) num -= mod;
            return this;
        }

        public ModInteger subtract(int n) {
            return getNewInstance(this).subtractEqual(n);
        }

        public ModInteger subtract(long n) {
            return getNewInstance(this).subtractEqual(n);
        }

        public ModInteger subtract(ModInteger n) {
            return getNewInstance(this).subtractEqual(n);
        }

        public ModInteger subtractEqual(int n) {
            num = validNum(num - n);
            return this;
        }

        public ModInteger subtractEqual(long n) {
            num = validNum(num - n);
            return this;
        }

        public ModInteger subtractEqual(ModInteger n) {
            if ((num -= n.num) &lt; 0) num += mod;
            return this;
        }

        public ModInteger multiply(int n) {
            return getNewInstance(this).multiplyEqual(n);
        }

        public ModInteger multiply(long n) {
            return getNewInstance(this).multiplyEqual(n);
        }

        public ModInteger multiply(ModInteger n) {
            return getNewInstance(this).multiplyEqual(n);
        }

        public ModInteger multiplyEqual(int n) {
            num = (int)((long)num * n % mod);
            if (num &lt; 0) num += mod;
            return this;
        }

        public ModInteger multiplyEqual(long n) {
            return multiplyEqual((int) (n % mod));
        }

        public ModInteger multiplyEqual(ModInteger n) {
            num = (int)((long)num * n.num % mod);
            return this;
        }

        public ModInteger divide(int n) {
            return getNewInstance(this).divideEqual(n);
        }

        public ModInteger divide(long n) {
            return getNewInstance(this).divideEqual(n);
        }

        public ModInteger divide(ModInteger n) {
            return getNewInstance(this).divideEqual(n);
        }

        public ModInteger divideEqual(int n) {
            num = (int)((long)num * inverse(validNum(n)) % mod);
            return this;
        }

        public ModInteger divideEqual(long n) {
            return divideEqual((int)(n % mod));
        }

        public ModInteger divideEqual(ModInteger n) {
            num = (int)((long)num * n.inverse(n.num) % mod);
            return this;
        }

        public ModInteger pow(int n) {
            return getNewInstance(this).powEqual(n);
        }

        public ModInteger pow(long n) {
            return getNewInstance(this).powEqual(n);
        }

        public ModInteger pow(ModInteger n) {
            return getNewInstance(this).powEqual(n);
        }

        public ModInteger powEqual(int n) {
            long ans = 1, num = this.num;
            if (n &lt; 0) {
                n = -n;
                while (n != 0) {
                    if ((n &amp; 1) != 0) ans = ans * num % mod;
                    n &gt;&gt;&gt;= 1;
            num = num * num % mod;
                }
                this.num = inverse((int)ans);
                return this;
            }
            while (n != 0) {
                if ((n &amp; 1) != 0) ans = ans * num % mod;
                n &gt;&gt;&gt;= 1;
                    num = num * num % mod;
            }
            this.num = (int)ans;
            return this;
        }
        public ModInteger powEqual(long n) {
            return powEqual((int)(n % (mod - 1)));
        }

        public ModInteger powEqual(ModInteger n) {
            long num = this.num;
            this.num = 1;
            int mul = n.num;
            while (mul != 0) {
                if ((mul &amp; 1) != 0) this.num *= num;
                mul &gt;&gt;&gt;= 1;
                num *= num;
                num %= mod;
            }
            return this;
        }

        public ModInteger equal(int n) {
            num = validNum(n);
            return this;
        }

        public ModInteger equal(long n) {
            num = validNum(n);
            return this;
        }

        public ModInteger equal(ModInteger n) {
            num = n.num;
            return this;
        }

        public int toInt() {
            return num;
        }

        public int getMod() {
            return mod;
        }

        @Override
        public boolean equals(Object x) {
            if (x instanceof ModInteger) return ((ModInteger)x).num == num &amp;&amp; ((ModInteger)x).mod == mod;
            return false;
        }

        @Override
        public int hashCode() {
            return num ^ mod;
        }

        @Override
        public String toString() {
            return String.valueOf(num);
        }

        @Deprecated
        public String debug() {
            int min = num, ans = 1;
            for (int i = 2;i &lt; min;++ i) {
                int tmp = multiply(i).num;
                if (min &gt; tmp) {
                    min = tmp;
                    ans = i;
                }
            }
            return min + &quot;/&quot; + ans;
        }

        @Override
        public Addition getAddition() {
            return add;
        }

        @Override
        public Multiplication getMultiplication() {
            return mul;
        }
    }
}
</PRE>

</BODY>
</HTML>
