<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>114_acw_guoqiaomixian.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>114_acw_guoqiaomixian.java</CENTER></H3><HR>
<PRE>
import java.io.*;
import java.util.*;

public class Solution{


    public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {
        List&lt;Integer&gt; hor = new ArrayList&lt;&gt;(), col = new ArrayList&lt;&gt;();
        hor.add(0);
        for(int hh : horizontalCuts) hor.add(hh);
        hor.add(h);
        col.add(0);
        for(int v : verticalCuts) col.add(v);
        col.add(w);
        Collections.sort(hor);
        Collections.sort(col);
        return calc(hor, col);
    }
    
    int calc(List&lt;Integer&gt; l1, List&lt;Integer&gt; l2)
    {
        int m = l1.size(), n = l2.size();
        if(m &gt; n) return calc(l2, l1);
        long dx = 0, dy = 0;
        long ans = 0;
        int mod = 1_000_000_007;
        for(int i = 0; i &lt; m - 1; i++)
        {
            int curDx = l1.get(i + 1) - l1.get(i);
            dx = Math.max(dx, curDx);
        }
        for(int j = 0; j &lt; n - 1; j++)
        {
            int curDy = l2.get(j + 1) - l2.get(j);
            dy = Math.max(dy, curDy);
        }
        
        return (int)(dx * dy % mod);
    }

        public int numSubseq(int[] nums, int target) {
        int n = nums.length;
        Arrays.sort(nums);
        int j = n - 1;
        long ans = 0, mod = 1_000_000_007;
        long[] pow = new long[1_000_10];
        pow[0] = 1;
        for(int i = 1; i &lt;= 100_000; i++)
        {
            pow[i] = pow[i - 1] * 2 % mod;
        }
        for(int i = 0; i &lt; n; i++)
        {
            while(j &gt;= i &amp;&amp; nums[i] + nums[j] &gt; target) j--;
            if(j &lt; i) break;
            int len = j - i;
            ans += pow[len];
        }
<A NAME="0"></A>        return (int)(ans % mod);
    }

        <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#0',2,'match31-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>public int findMaxValueOfEquation(int[][] points, int k) {
        int n = points.length;
        int j = 0;
        Deque&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        int maxi = Integer.MIN_VALUE;
        for(int i = 0; i &lt; n; i++)
        {</B></FONT>
            int xi = points[i][0];
            int yi = points[i][1];
            while(!q.isEmpty() &amp;&amp; q.peekFirst()[0] + k &lt; xi) q.pollFirst();
            if(!q.isEmpty()) maxi = Math.max(maxi, q.peekFirst()[1] + yi + xi);
            while(!q.isEmpty() &amp;&amp; q.peekLast()[1] &lt;= yi - xi) q.pollLast();
            q.offerLast(new int[]{xi, yi - xi});
        }
        return maxi;
    }

    

    class Point{
        double x;
        double y;
        Point(double X,double Y){
            x = X;
            y = Y;
        }
        
        double atan(){
            return Math.atan2(y,x);
        }
        double length() {
            return Math.sqrt(x*x+y*y+1e-7);
        }
        Point add(Point Q) {
            return new Point(x+Q.x,y+Q.y);
        }
        Point sub(Point Q) {
            return new Point(x-Q.x,y-Q.y);
        }
        Point mul(double d) {
            return new Point(x*d,y*d);
        }
        Point div(double d) {
            return new Point(x/d,y/d);
        }
        
    }


    class Triangle{
        double eps = 1e-7;
        Point A;
        Point B;
        Point C;
        double edgeA;
        double edgeB;
        double edgeC;
        double argA;
        double argB;
        double argC;
        Triangle(Point a,Point b,Point c){
            A = a;
            B = b;
            C = c;
            edgeA = b.sub(c).length();
            edgeB = c.sub(a).length();
            edgeC = a.sub(b).length();
            argA = Math.acos(getcos(edgeA,edgeB,edgeC));
            argB = Math.acos(getcos(edgeB,edgeC,edgeA));
            argC = Math.acos(getcos(edgeC,edgeA,edgeB));
        }
        double getcos(double a,double b,double c){
            return (b*b+c*c-a*a)/(2*b*c);
        }
        Point outheart() {
            return A.mul(Math.sin(2*argA)).add(B.mul(Math.sin(2*argB))).add(C.mul(Math.sin(2*argC))).div(Math.sin(2*argA)+Math.sin(2*argB)+Math.sin(2*argC));
        }
    }

    class Slidemax{
        int[] dat;
        
        ArrayDeque&lt;LongIntPair&gt; q = new ArrayDeque&lt;LongIntPair&gt;();
        
        long get() {
            if(q.isEmpty()) return (long) -1e17;
            return q.peek().a;
        }
        
        void remove() {
            q.getFirst().b--;
            if(q.getFirst().b==0)q.pollFirst();
        }
        
        void add(long x) {
            int num = 1;
            while(!q.isEmpty()&amp;&amp;q.peekLast().a&lt;=x) {
                num += q.peekLast().b;
                q.pollLast();
            }
            q.addLast(new LongIntPair(x,num));
        }
    }
    class Slidemin{
        int[] dat;
        int l = 0;
        int r = -1;
        ArrayDeque&lt;LongIntPair&gt; q = new ArrayDeque&lt;LongIntPair&gt;();
        
        long get() {
            if(q.isEmpty()) return (long)1e17;
            return q.peek().a;
        }
        
        void remove() {
            q.getFirst().b--;
            if(q.getFirst().b==0)q.pollFirst();
        }
        
        void add(long x) {
            int num = 1;
            while(!q.isEmpty()&amp;&amp;q.peekLast().a&gt;=x) {
                num += q.peekLast().b;
                q.pollLast();
            }
            q.addLast(new LongIntPair(x,num));
        }
    }


    class Counter{
        
        int[] cnt;
        Counter(int M){
            cnt = new int[M+1];
        }
        Counter(int M,int[] A){
            cnt = new int[M+1];
            for(int i=0;i&lt;A.length;i++)add(A[i]);
        }
        void add(int e) {
            cnt[e]++;
        }
        void remove(int e) {
            cnt[e]--;
        }
        int count(int e) {
            return cnt[e];
        }
    }

    class MultiHashSet{
        HashMap&lt;Integer,Integer&gt; set;
        int size;
        long sum;
        MultiHashSet(){
            set = new HashMap&lt;Integer,Integer&gt;();
            size = 0;
            sum = 0;
        }
        void add(int e){
            if(set.containsKey(e))set.put(e,set.get(e)+1);
            else set.put(e,1);
            size++;
            sum += e;
        }
        void remove(int e) {
            set.put(e,set.get(e)-1);
            if(set.get(e)==0)set.remove(e);
            size--;
            sum -= e;
        }
        
        boolean contains(int e) {
            return set.containsKey(e);
        }
        boolean isEmpty() {
            return set.isEmpty();
        }
        int count(int e) {
            if(contains(e))return set.get(e);
            else return 0;
        }
        
        Set&lt;Integer&gt; keyset(){
            return set.keySet();
        }

    }


    class MultiSet{
        TreeMap&lt;Integer,Integer&gt; set;
        long size;
        long sum;
        MultiSet(){
            set = new TreeMap&lt;Integer,Integer&gt;();
            size = 0;
            sum = 0;
        }
        void add(int e){
            if(set.containsKey(e))set.put(e,set.get(e)+1);
            else set.put(e,1);
            size++;
            sum += e;
        }
        void addn(int e,int n){
            if(set.containsKey(e))set.put(e,set.get(e)+n);
            else set.put(e,n);
            size += n;
            sum += e*(long)n;
        }
        void remove(int e) {
            set.put(e,set.get(e)-1);
            if(set.get(e)==0)set.remove(e);
            size--;
            sum -= e;
        }
        int first() {return set.firstKey();}
        int last() {return set.lastKey();}
        int lower(int e) {return set.lowerKey(e);}
        int higher(int e) {return set.higherKey(e);}
        int floor(int e) {return set.floorKey(e);}
        int ceil(int e) {return set.ceilingKey(e);}
        boolean contains(int e) {return set.containsKey(e);}
        boolean isEmpty() {return set.isEmpty();}
        int count(int e) {
            if(contains(e))return set.get(e);
            else return 0;
        }
        MultiSet marge(MultiSet T) {
            if(size&gt;T.size) {
                while(!T.isEmpty()) {
                    add(T.first());
                    T.remove(T.first());
                }
                return this;
            }else {
                while(!isEmpty()) {
                    T.add(first());
                    remove(first());
                }
                return T;
            }
        }
        Set&lt;Integer&gt; keyset(){
            return set.keySet();
        }

    }

    class MultiSetL{
        TreeMap&lt;Long,Integer&gt; set;
        int size;
        long sum;
        MultiSetL(){
            set = new TreeMap&lt;Long,Integer&gt;();
            size = 0;
            sum = 0;
        }
        void add(long e){
            if(set.containsKey(e))set.put(e,set.get(e)+1);
            else set.put(e,1);
            size++;
            sum += e;
        }
        void remove(long e) {
            set.put(e,set.get(e)-1);
            if(set.get(e)==0)set.remove(e);
            size--;
            sum -= e;
        }
        long first() {return set.firstKey();}
        long last() {return set.lastKey();}
        long lower(long e) {return set.lowerKey(e);}
        long higher(long e) {return set.higherKey(e);}
        long floor(long e) {return set.floorKey(e);}
        long ceil(long e) {return set.ceilingKey(e);}
        boolean contains(long e) {return set.containsKey(e);}
        boolean isEmpty() {return set.isEmpty();}
        int count(long e) {
            if(contains(e))return set.get(e);
            else return 0;
        }
        MultiSetL marge(MultiSetL T) {
            if(size&gt;T.size) {
                while(!T.isEmpty()) {
                    add(T.first());
                    T.remove(T.first());
                }
                return this;
            }else {
                while(!isEmpty()) {
                    T.add(first());
                    remove(first());
                }
                return T;
            }
        }
        Set&lt;Long&gt; keyset(){
            return set.keySet();
        }
    }



    class BetterGridGraph{
        int N;
        int M;
        char[][] S;
        HashMap&lt;Character,ArrayList&lt;Integer&gt;&gt; map;
        int[] dx = {0,1,0,-1};
        int[] dy = {1,0,-1,0};
        char w;
        char b = '#';
        BetterGridGraph(int n,int m,String[] s,char[] c){

            N = n;
            M = m;
            for(int i=0;i&lt;s.length;i++) {
                S[i] = s[i].toCharArray();
            }
            map = new HashMap&lt;Character,ArrayList&lt;Integer&gt;&gt;();
            for(int i=0;i&lt;c.length;i++) {
                map.put(c[i],new ArrayList&lt;Integer&gt;());
            }
            for(int i=0;i&lt;n;i++) {
                for(int j=0;j&lt;m;j++) {
                    for(int k=0;k&lt;c.length;k++) {
                        if(S[i][j]==c[k])map.get(c[k]).add(toint(i,j));
                    }
                }
            }
        }
        BetterGridGraph(int n,int m,char[][] s,char[] c){

            N = n;
            M = m;
            S = s;
            map = new HashMap&lt;Character,ArrayList&lt;Integer&gt;&gt;();
            for(int i=0;i&lt;c.length;i++) {
                map.put(c[i],new ArrayList&lt;Integer&gt;());
            }
            for(int i=0;i&lt;n;i++) {
                for(int j=0;j&lt;m;j++) {
                    for(int k=0;k&lt;c.length;k++) {
                        if(S[i][j]==c[k])map.get(c[k]).add(toint(i,j));
                    }
                }
            }
        }

        BetterGridGraph(int n,int m,String[] s,char[] c,char W,char B){

            N = n;
            M = m;
            for(int i=0;i&lt;s.length;i++) {
                S[i] = s[i].toCharArray();
            }
            w = W;
            b = B;
            map = new HashMap&lt;Character,ArrayList&lt;Integer&gt;&gt;();
            for(int i=0;i&lt;c.length;i++) {
                map.put(c[i],new ArrayList&lt;Integer&gt;());
            }
            for(int i=0;i&lt;n;i++) {
                for(int j=0;j&lt;m;j++) {
                    for(int k=0;k&lt;c.length;k++) {
                        if(S[i][j]==c[k])map.get(c[k]).add(toint(i,j));
                    }
                }
            }
        }
        BetterGridGraph(int n,int m,char[][] s,char[] c,char W,char B){

            N = n;
            M = m;
            S = s;
            w = W;
            b = B;
            map = new HashMap&lt;Character,ArrayList&lt;Integer&gt;&gt;();
            for(int i=0;i&lt;c.length;i++) {
                map.put(c[i],new ArrayList&lt;Integer&gt;());
            }
            for(int i=0;i&lt;n;i++) {
                for(int j=0;j&lt;m;j++) {
                    for(int k=0;k&lt;c.length;k++) {
                        if(S[i][j]==c[k])map.get(c[k]).add(toint(i,j));
                    }
                }
            }
        }

        int toint(int i,int j) {
            return i*M+j;
        }
        
        ArrayList&lt;Integer&gt; getposlist(char c) {
            return map.get(c);
        }
        
        int getpos(char c) {
            return map.get(c).get(0);
        }

        int[] bfs(char C) {
            int[] L = new int[N*M];
            ArrayDeque&lt;Integer&gt; Q = new ArrayDeque&lt;Integer&gt;();
            for(int i=0;i&lt;N*M;i++){
                L[i] = -1;
            }
            for(int s:map.get(C)) {
                L[s] = 0;
                Q.add(s);
            }
            Range X = new Range(0,N-1);
            Range Y = new Range(0,M-1);
            while(!Q.isEmpty()){
                int v = Q.poll();
                for(int i=0;i&lt;4;i++){
                    int x = v/M;
                    int y = v%M;
                    int nx = x+dx[i];
                    int ny = y+dy[i];
                    if(X.isIn(nx)&amp;&amp;Y.isIn(ny)&amp;&amp;S[nx][ny]!=b) {
                        int w = toint(nx,ny);
                        if(L[w]==-1){
                            L[w] = L[v] + 1;
                            Q.add(w);
                        }
                    }
                }
            }
            return L;
        }
        
        int[] bfsb(int s) {
            int[] L = new int[N*M];
            ArrayDeque&lt;Integer&gt; Q = new ArrayDeque&lt;Integer&gt;();
            for(int i=0;i&lt;N*M;i++){
                L[i] = -1;
            }
            Q.add(s);
            L[s] = 0;
            Range X = new Range(0,N-1);
            Range Y = new Range(0,M-1);
            while(!Q.isEmpty()){
                int v = Q.poll();
                for(int i=0;i&lt;4;i++){
                    int x = v/M;
                    int y = v%M;
                    int nx = x+dx[i];
                    int ny = y+dy[i];
                    if(X.isIn(nx)&amp;&amp;Y.isIn(ny)) {
                        int w = toint(nx,ny);
                        if(L[w]==-1){
                            if(S[x][y]==S[nx][ny]) {
                                L[w] = L[v];
                                Q.addFirst(w);
                            }else {
                                L[w] = L[v] + 1;
                                Q.addLast(w);
                            }
                        }
                    }
                }
            }
            return L;
        }

        
    }
    class IntGridGraph{
        int N;
        int M;
        int[][] B;
        int[] dx = {0,1,0,-1};
        int[] dy = {1,0,-1,0};
        BiFunction&lt;Integer,Integer,Boolean&gt; F;
        
        IntGridGraph(int n,int m,int[][] b){

            N = n;
            M = m;
            B = b;
        }
        IntGridGraph(int n,int m,int[][] b,BiFunction&lt;Integer,Integer,Boolean&gt; f){

            N = n;
            M = m;
            B = b;
            F = f;
        }
        
            
        int toint(int i,int j) {
            return i*M+j;
        }
        

        int[] bfs(int s) {
            int[] L = new int[N*M];
            for(int i=0;i&lt;N*M;i++){
                L[i] = -1;
            }
            L[s] = 0;
            ArrayDeque&lt;Integer&gt; Q = new ArrayDeque&lt;Integer&gt;();
            Q.add(s);
            Range X = new Range(0,N-1);
            Range Y = new Range(0,M-1);
            while(!Q.isEmpty()){
                int v = Q.poll();
                for(int i=0;i&lt;4;i++){
                    int x = v/M;
                    int y = v%M;
                    int nx = x+dx[i];
                    int ny = y+dy[i];
                    if(X.isIn(nx)&amp;&amp;Y.isIn(ny)&amp;&amp;F.apply(B[x][y],B[nx][ny])) {
                    int w = toint(nx,ny);                        
                        if(L[w]==-1){
                            L[w] = L[v] + 1;
                            Q.add(w);
                        }
                    }
                }
            }
            return L;
        }
        
        void bfs(int s,int[] L) {
            
            if(L[s]!=-1) return;
            L[s] = 0;
            ArrayDeque&lt;Integer&gt; Q = new ArrayDeque&lt;Integer&gt;();
            Q.add(s);
            Range X = new Range(0,N-1);
            Range Y = new Range(0,M-1);
            while(!Q.isEmpty()){
                int v = Q.poll();
                for(int i=0;i&lt;4;i++){
                    int x = v/M;
                    int y = v%M;
                    int nx = x+dx[i];
                    int ny = y+dy[i];
                    if(X.isIn(nx)&amp;&amp;Y.isIn(ny)&amp;&amp;F.apply(B[x][y],B[nx][ny])) {
                    int w = toint(nx,ny);                        
                        if(L[w]==-1){
                            L[w] = L[v] + 1;
                            Q.add(w);
                        }
                    }
                }
            }
            return;
        }

       
    }

    class Trie{
        int nodenumber = 1;
        ArrayList&lt;TrieNode&gt; l;
        Trie(){
            l = new ArrayList&lt;TrieNode&gt;();
            l.add(new TrieNode());
        }

        void add(String S,int W){
            int now = 0;
            for(int i=0;i&lt;S.length();i++) {
                TrieNode n = l.get(now);
                char c = S.charAt(i);
                if(n.Exist[c-'a']!=-1) {
                    now = n.Exist[c-'a'];
                }else {
                    l.add(new TrieNode());
                    n.Exist[c-'a'] = nodenumber;
                    now = nodenumber;
                    nodenumber++;
                }
            }
            l.get(now).weight = W;
        }

        void find(String S,int i,int[] dp) {
            int now = 0;
            dp[i+1] = Math.max(dp[i],dp[i+1]);
            for(int j=0;;j++) {
                TrieNode n = l.get(now);
                dp[i+j] = Math.max(dp[i+j],dp[i]+n.weight);
                int slook = i+j;
                if(slook&gt;=S.length())return;
                char c = S.charAt(slook);
                if(n.Exist[c-'a']==-1)return;
                now = n.Exist[c-'a'];
            }
        }
    }

    class TrieNode{

        int[] Exist = new int[26];
        int weight = 0;
        TrieNode(){
            for(int i=0;i&lt;26;i++) {
                Exist[i] = -1;
            }
        }
    }

    class SizeComparator implements Comparator&lt;Edge&gt;{
        int[] size;
        SizeComparator(int[] s) {
            size = s;
        }

        public int compare(Edge o1, Edge o2) {
            return size[o1.to]-size[o2.to];

        }

    }

    class ConvexHullTrick {
        long[] A, B;
        int len;

<A NAME="1"></A>        public ConvexHullTrick(int n) {
            A = new long[n];
            B = new long[n];
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#1',2,'match31-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        private boolean check(long a, long b) {
            return (B[len - 2] - B[len - 1]) * (a - A[len - 1]) &gt;= (B[len - 1] - b) * (A[len - 1] - A[len - 2]);
        }

        public void add(long a, long b) {</B></FONT>
            while (len &gt;= 2 &amp;&amp; check(a, b)) {
                len--;
            }
            A[len] = a;
            B[len] = b;
            len++;
        }

        public long query(long x) {
            int l = -1, r = len - 1;
            while (r - l &gt; 1) {
                int mid = (r + l) / 2;
                if (get(mid,x)&gt;=get(mid+1,x)) {
                    l = mid;
                } else {
                    r = mid;
                }
            }
            return get(r,x);
        }

        private long get(int k, long x) {
            return A[k] * x + B[k];
        }
    }

    class Range{
        long l;
        long r;
        long length;
        Range(int L,int R){
            l = L;
            r = R;
            length = R-L+1;
        }

        public Range(long L, long R) {
            l = L;
            r = R;
            length = R-L+1;
        }

        boolean isIn(int x) {
            return (l&lt;=x&amp;&amp;x&lt;=r);

        }
        long kasanari(Range S) {
            if(this.r&lt;S.l||S.r&lt;this.l) return 0;
            else return Math.min(this.r,S.r) - Math.max(this.l,S.l)+1;
        }
    }
    class LeftComparator implements Comparator&lt;Range&gt;{
        public int compare(Range P, Range Q) {
            return (int) Math.signum(P.l-Q.l);
        }
    }
    class RightComparator implements Comparator&lt;Range&gt;{
        public int compare(Range P, Range Q) {
            return (int) Math.signum(P.r-Q.r);
                    
        }
    }
    class LengthComparator implements Comparator&lt;Range&gt;{
        public int compare(Range P, Range Q) {
            return (int) Math.signum(P.length-Q.length);
        }
    }
    class SegmentTree&lt;T,E&gt;{
        int N;
        BiFunction&lt;T,T,T&gt; f;
        BiFunction&lt;T,E,T&gt; g;
        T d1;
        ArrayList&lt;T&gt; dat;
        SegmentTree(BiFunction&lt;T,T,T&gt; F,BiFunction&lt;T,E,T&gt; G,T D1,T[] v){
            int n = v.length;
            f = F;
            g = G;
            d1 = D1;
            init(n);
            build(v);
        }


        void init(int n) {
            N = 1;
            while(N&lt;n)N*=2;
            dat = new ArrayList&lt;T&gt;();
        }

        void build(T[] v) {
            for(int i=0;i&lt;2*N;i++) {
                dat.add(d1);
            }
            for(int i=0;i&lt;v.length;i++) {
                dat.set(N+i-1,v[i]);
            }
            for(int i=N-2;i&gt;=0;i--) {
                dat.set(i,f.apply(dat.get(i*2+1),dat.get(i*2+2)));
            }
        }

        void update(int k,E a) {
            k += N-1;
            dat.set(k,g.apply(dat.get(k),a));
            while(k&gt;0){
                k = (k-1)/2;
                dat.set(k,f.apply(dat.get(k*2+1),dat.get(k*2+2)));
            }
        }

        T query(int a,int b, int k, int l ,int r) {
            if(r&lt;=a||b&lt;=l) return d1;
            if(a&lt;=l&amp;&amp;r&lt;=b) return dat.get(k);
            T vl = query(a,b,k*2+1,l,(l+r)/2);
            T vr = query(a,b,k*2+2,(l+r)/2,r);
            return f.apply(vl,vr);
        }
        T query(int a,int b){
            return query(a,b,0,0,N);
        }

    }

    class LazySegmentTree&lt;T,E&gt; extends SegmentTree&lt;T,E&gt;{
        BiFunction&lt;E,E,E&gt; h;
        BiFunction&lt;E,Integer,E&gt; p = (E a,Integer b) -&gt;{return a;};
        E d0;
        ArrayList&lt;E&gt; laz;
        LazySegmentTree(BiFunction&lt;T,T,T&gt; F,BiFunction&lt;T,E,T&gt; G,BiFunction&lt;E,E,E&gt; H,T D1,E D0,T[] v){
            super(F,G,D1,v);
            int n = v.length;
            h = H;
            d0 = D0;
            Init(n);
        }
        void build() {

        }
        void Init(int n){
            laz = new ArrayList&lt;E&gt;();
            for(int i=0;i&lt;2*N;i++) {
                laz.add(d0);
            }
        }

        void eval(int len,int k) {
            if(laz.get(k).equals(d0)) return;
            if(k*2+1&lt;N*2-1) {
                laz.set(k*2+1,h.apply(laz.get(k*2+1),laz.get(k)));
                laz.set(k*2+2,h.apply(laz.get(k*2+2),laz.get(k)));
            }
            dat.set(k,g.apply(dat.get(k), p.apply(laz.get(k), len)));
            laz.set(k,d0);
        }

        T update(int a,int b,E x,int k,int l,int r) {
            eval(r-l,k);
            if(r&lt;=a||b&lt;=l) {
                return dat.get(k);
            }
            if(a&lt;=l&amp;&amp;r&lt;=b) {
                laz.set(k,h.apply(laz.get(k),x));
                return g.apply(dat.get(k),p.apply(laz.get(k),r-l));
            }
            T vl = update(a,b,x,k*2+1,l,(l+r)/2);
            T vr = update(a,b,x,k*2+2,(l+r)/2,r);
            dat.set(k,f.apply(vl,vr));
            return dat.get(k);

        }

        T update(int a,int b,E x) {
            return update(a,b,x,0,0,N);
        }

        T query(int a,int b,int k,int l,int r) {
            
            eval(r-l,k);
            if(r&lt;=a||b&lt;=l) return d1;
            if(a&lt;=l&amp;&amp;r&lt;=b) return dat.get(k);
            T vl = query(a,b,k*2+1,l,(l+r)/2);
            T vr = query(a,b,k*2+2,(l+r)/2,r);
            return f.apply(vl, vr);
        }

        T query(int a,int b){
            return query(a,b,0,0,N);
        }

    }

    class AddSumSegmentTree{
        int N;
        int d1;
        ArrayList&lt;Integer&gt; dat;
        AddSumSegmentTree(int[] v){
            int n = v.length;
            init(n);
            build(v);
        }

        void init(int n) {
            N = 1;
            while(N&lt;n)N*=2;
            dat = new ArrayList&lt;Integer&gt;();
        }

        void build(int[] v) {
            for(int i=0;i&lt;2*N;i++) {
                dat.add(d1);
            }
            for(int i=0;i&lt;v.length;i++) {
                dat.set(N+i-1,v[i]);
            }
            for(int i=N-2;i&gt;=0;i--) {
                dat.set(i,dat.get(i*2+1)+dat.get(i*2+2));
            }
        }

        void update(int k,int a) {
            k += N-1;
            dat.set(k,dat.get(k)+a);
            while(k&gt;0){
                k = (k-1)/2;
                dat.set(k,dat.get(k*2+1)+dat.get(k*2+2));
            }
        }

        int query(int a,int b, int k, int l ,int r) {
            if(r&lt;=a||b&lt;=l) return d1;
            if(a&lt;=l&amp;&amp;r&lt;=b) return dat.get(k);
            int vl = query(a,b,k*2+1,l,(l+r)/2);
            int vr = query(a,b,k*2+2,(l+r)/2,r);
            return vl+vr;
        }
        int query(int a,int b){
            return query(a,b,0,0,N);
        }
    }
    class AddSumLazySegmentTree {
        int N;
        long[] dat;
        long[] laz;
        AddSumLazySegmentTree(long[] v){
            init(v.length);

            for(int i=0;i&lt;v.length;i++) {
                dat[N+i-1]=v[i];
            }
            for(int i=N-2;i&gt;=0;i--) {
                dat[i]=dat[i*2+1]+dat[i*2+2];
            }
        }

        void init(int n) {
            N = 1;
            while(N&lt;n)N*=2;
            dat = new long[2*N];
            laz = new long[2*N];
        }


        void eval(int len,int k) {
            if(laz[k]==0) return;
            if(k*2+1&lt;N*2-1) {
                laz[k*2+1] += laz[k];
                laz[k*2+2] += laz[k];
            }
            dat[k] += laz[k] * len;
            laz[k] = 0;
        }

        long update(int a,int b,long x,int k,int l,int r) {
            eval(r-l,k);
            if(r&lt;=a||b&lt;=l) {
                return dat[k];
            }
            if(a&lt;=l&amp;&amp;r&lt;=b) {
                laz[k] += x;
                return dat[k]+laz[k]*(r-l);
            }
            long vl = update(a,b,x,k*2+1,l,(l+r)/2);
            long vr = update(a,b,x,k*2+2,(l+r)/2,r);
            return dat[k] = vl+vr;


        }

        long update(int a,int b,long x) {
            return update(a,b,x,0,0,N);
        }

        long query(int a,int b,int k,int l,int r) {
            eval(r-l,k);
            if(r&lt;=a||b&lt;=l) return 0;
            if(a&lt;=l&amp;&amp;r&lt;=b) return dat[k];

            long vl = query(a,b,k*2+1,l,(l+r)/2);
            long vr = query(a,b,k*2+2,(l+r)/2,r);
            return vl+vr;
        }

        long query(int a,int b){
            return query(a,b,0,0,N);
        }

    }

    class BinaryIndexedTree{
        int[] val;
        BinaryIndexedTree(int N){
            val = new int[N+1];
        }
        long sum(int i) {
            if(i==0)return 0;
            long s = 0;
            while(i&gt;0) {
                s += val[i];
                i -= i &amp; (-i);
            }
            return s;
        }
        void add(int i,int x) {
            if(i==0)return;
            while(i&lt;val.length){
                val[i] += x;
                i += i &amp; (-i);
            }
        }
    }


    class UnionFindTree {
        int[] root;
        int[] rank;
        long[] size;
        int[] edge;
        int num;
        UnionFindTree(int N){
            root = new int[N];
            rank = new int[N];
            size = new long[N];
            edge = new int[N];
            num = N;
            for(int i=0;i&lt;N;i++){
                root[i] = i;
                size[i] = 1;
            }
        }
        public long size(int x) {
            return size[find(x)];
        }
        public boolean isRoot(int x) {
            return x==find(x);
        }
        public long extraEdge(int x) {
            int r = find(x);
            return edge[r] - size[r] + 1;
        }
        public int find(int x){
            if(root[x]==x){
                return x;
            }else{
                return find(root[x]);
            }
        }

        public boolean unite(int x,int y){
            x = find(x);
            y = find(y);
            if(x==y){
                edge[x]++;
                return false;
            }else{
                num--;
                if(rank[x]&lt;rank[y]){
                    root[x] = y;
                    size[y] += size[x];
                    edge[y] += edge[x]+1;
                }else{
                    root[y] = x;
                    size[x] += size[y];
                    edge[x] += edge[y]+1;
                    if(rank[x]==rank[y]){
                        rank[x]++;
                    }
                }
                return true;
            }
        }

        public boolean same(int x,int y){
            return find(x)==find(y);
        }

    }
    class LightUnionFindTree {
        int[] par;
        int num;
        LightUnionFindTree(int N){
            par = new int[N];
            num = N;
            for(int i=0;i&lt;N;i++){
                par[i] = -1;
            }
        }
        public boolean isRoot(int x) {
            return x==find(x);
        }
        
        public int find(int x){
            if(par[x]&lt;0){
                return x;
            }else{
                return find(par[x]);
            }
        }

        public void unite(int x,int y){
            x = find(x);
            y = find(y);
            if(x==y){
                return;
            }else{
                num--;
                if(par[x]&lt;par[y]){
                    par[x] += par[y];
                    par[y] = x;
                }else{
                    par[y] += par[x];
                    par[x] = y;
                }
            }
        }

        public boolean same(int x,int y){
            return find(x)==find(y);
        }

    }

    class ParticalEternalLastingUnionFindTree extends UnionFindTree{
        int[] time;
        int now;
        ParticalEternalLastingUnionFindTree(int N){
            super(N);
            time = new int[N];
            for(int i=0;i&lt;N;i++) {
                time[i] = 1000000007;
            }
        }

        public int find(int t,int i) {
            if(time[i]&gt;t) {
                return i;
            }else {
                return find(t,root[i]);
            }
        }

        public void unite(int x,int y,int t) {
            now = t;
            x = find(t,x);
            y = find(t,y);
            if(x==y)return;
            if(rank[x]&lt;rank[y]){
                root[x] = y;
                size[y] += size[x];
                time[x] = t;
            }else{
                root[y] = x;
                size[x] += size[y];
                if(rank[x]==rank[y]){
                    rank[x]++;
                }
                time[y] = t;
            }
        }

        public int sametime(int x,int y) {
            if(find(now,x)!=find(now,y)) return -1;
            int ok = now;
<A NAME="2"></A>            int ng = 0;
            while(ok-ng&gt;1) {
                int mid = (ok+ng)/2;
                if(find(mid,x)==find(mid,y)) <FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#2',2,'match31-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
                    ok = mid;
                }else {
                    ng = mid;
                }
            }
            return ok;
        }


    }</B></FONT>
    class FlowEdge{
        int to;
        long cap;
        int rev = 0;
        FlowEdge(int To,long Cap,int Rev){
            to = To;
            cap = Cap;
            rev = Rev;
        }
    }
    class FlowGraph{
        ArrayList&lt;FlowEdge&gt;[] list;
        int[] level;
        int[] iter;
        ArrayDeque&lt;Integer&gt; q;
        FlowGraph(int N){
            list = new ArrayList[N];
            for(int i=0;i&lt;N;i++) {
                list[i] = new ArrayList&lt;FlowEdge&gt;();
            }
            level = new int[N];
            iter = new int[N];
            q = new ArrayDeque&lt;Integer&gt;();
        }
        
        void addEdge(int i, int to, long cap) {
            list[i].add(new FlowEdge(to,cap,list[to].size()));
            list[to].add(new FlowEdge(i,0,list[i].size()-1));
        }
        
        void bfs(int s) {
            Arrays.fill(level,-1);
            level[s] = 0;
            q.add(s);
            while(!q.isEmpty()) {
                int v = q.poll();
                for(FlowEdge e:list[v]) {
                    if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0) {
                        level[e.to] = level[v] + 1;
                        q.add(e.to);
                    }
                }
            }
        }
        
        long dfs(int v,int t,long f) {
            if(v==t) return f;
            for(int i = iter[v];i&lt;list[v].size();i++) {
                FlowEdge e = list[v].get(i);
                if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]) {
                    long d = dfs(e.to,t,Math.min(f,e.cap));
                    if(d&gt;0) {
                        e.cap -= d;
                        list[e.to].get(e.rev).cap += d;
                        return d;
                    }
                }
                iter[v]++;
            }
            return 0;
        }
        
        long flow(int s,int t,long lim) {
            long flow = 0;
            while(true) {
                bfs(s);
                if(level[t]&lt;0||lim==0) return flow;
                Arrays.fill(iter,0);
                while(true) {
                    long f = dfs(s,t,lim);
                    if(f&gt;0) {
                        flow += f;
                        lim -= f;
                    }
                    
                    else break;
                }
            }
            
        }
        long flow(int s,int t) {
            return flow(s,t,1000000007);
        }
    }


    class LightGraph {
        ArrayList&lt;Integer&gt;[] list;
        int size;
        TreeSet&lt;LinkEdge&gt; Edges = new TreeSet&lt;LinkEdge&gt;(new LinkEdgeComparator());

        @SuppressWarnings(&quot;unchecked&quot;)
        LightGraph(int N){
            size = N;
            list = new ArrayList[N];
            for(int i=0;i&lt;N;i++){
                list[i] = new ArrayList&lt;Integer&gt;();
            }
        }

        




        void addEdge(int a,int b){
            list[a].add(b);
        }

        
        public Stack&lt;Integer&gt; findCycle() {
            Stack&lt;Integer&gt; ans = new Stack&lt;Integer&gt;();
            boolean[] v = new boolean[size];
            boolean[] f = new boolean[size];
            for(int i=0;i&lt;size;i++) {
                if(findCycle(i,ans,v,f))break;
            }
            return ans;
        }
        private boolean findCycle(int i, Stack&lt;Integer&gt;ans, boolean[] v,boolean[] f) {
            v[i] = true;
            ans.push(i);
            for(int e:list[i]) {
                if(f[e]) continue;
                if(v[e]&amp;&amp;!f[e]) {
                    return true;
                }
                if(findCycle(e,ans,v,f))return true;
            }
            ans.pop();
            f[i] = true;
            return false;
            
        }
        
    }


    class LinkEdge{
        long L;
        int a ;
        int b;
        int id;
        LinkEdge(long l,int A,int B){
            L = l;
            a = A;
            b = B;
        }
        LinkEdge(long l,int A,int B,int i){
            L = l;
            a = A;
            b = B;
            id = i;
        }
        public boolean equals(Object o){
            LinkEdge O = (LinkEdge) o;
            return O.a==this.a&amp;&amp;O.b==this.b&amp;&amp;O.L==this.L;
        }

        public int hashCode(){
            return Objects.hash(L,a,b);
        }
    }

    class DoubleLinkEdge{
        double D;
        int a;
        int b;
        DoubleLinkEdge(double d,int A,int B){
            D = d;
            a = A;
            b = B;
        }
        public boolean equals(Object o){
            DoubleLinkEdge O = (DoubleLinkEdge) o;
            return O.a==this.a&amp;&amp;O.b==this.b&amp;&amp;O.D==this.D;
        }
     
        public int hashCode(){
            return Objects.hash(D,a,b);
        }
    }
     

    class Edge{
        int to;
        long cost;
        Edge(int a,long b){
            to = a;
            cost = b;
        }
    }

    class indexedEdge extends Edge{
        int id;
        indexedEdge(int a, long b, int c) {
            super(a,b);
            id = c;
        }
        
    }

    class DoubleLinkEdgeComparator implements Comparator&lt;DoubleLinkEdge&gt;{
        public int compare(DoubleLinkEdge P, DoubleLinkEdge Q) {
            return Double.compare(P.D,Q.D);
        }
    }

    class LinkEdgeComparator implements Comparator&lt;LinkEdge&gt;{
        public int compare(LinkEdge P, LinkEdge Q) {
            return Long.compare(P.L,Q.L);
        }
    }


    class Pair{
        long a;
        long b;

        Pair(long p,long q){
            this.a = p;
            this.b = q;
        }

        public boolean equals(Object o){
            Pair O = (Pair) o;
            return O.a==this.a&amp;&amp;O.b==this.b;
        }

        public int hashCode(){
            return Objects.hash(a,b);
        }
    }

    class SampleComparator implements Comparator&lt;Pair&gt;{
        public int compare(Pair P, Pair Q) {
            long t = P.a-Q.a;
            if(t==0){
                if(P.b==Q.b)return 0;
                return P.b&gt;Q.b?1:-1;

            }
            return t&gt;=0?1:-1;
        }
    }


    class LongIntPair{
        long a;
        int b;

        LongIntPair(long p,int q){
            this.a = p;
            this.b = q;
        }

        public boolean equals(Object o){
            LongIntPair O = (LongIntPair) o;
            return O.a==this.a&amp;&amp;O.b==this.b;

        }

        public int hashCode(){
            return Objects.hash(a,b);
        }
    }

    class LongIntComparator implements Comparator&lt;LongIntPair&gt;{
        public int compare(LongIntPair P, LongIntPair Q) {
            long t = P.a-Q.a;
            if(t==0){
                if(P.b&gt;Q.b){
                    return 1;
                }else{
                    return -1;
                }
            }
            return t&gt;=0?1:-1;
        }
    }

}
</PRE>

</BODY>
</HTML>
